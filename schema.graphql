scalar DateTime

""" These unions are a way for a property to hold references to different types """
union Enterable = Group | Person | Reference | Schema | Character | State | Description | CharacterInstance | Specimen

union Groupable = Reference | Schema | Character | State | Description | CharacterInstance | Specimen

union Authorable = Reference | Schema

union Statable = Character | State

type Group {
    pbotID: ID!
    name: String
    members: [Person!]! @relation(name: "MEMBER_OF", direction: IN)
    elements: [Groupable!]! @relation(name: "ELEMENT_OF", direction: IN)
    enteredBy: [GroupEnteredBy]
}

""" Note that I had to use the cypher directive to populate the entered property.
    Ideally, this would be handled by a relation directive, but that does not appear to
    work with unions. """
type Person {
    pbotID: ID!
    given: String
    surname: String
    email: String
    orcid: String
    entered:   [Enterable] @cypher(
      statement: "match (n)-[:ENTERED_BY]->(this) return n"
    )
    authored: [Authorable!]! @relation(name: "AUTHORED_BY", direction: IN)
    memberOf: [Group!]! @relation(name: "MEMBER_OF", direction: OUT)
    enteredBy: [PersonEnteredBy]
}

type Reference {
    pbotID: ID!
    title: String
    year: String
    publisher: String
    doi: String
    citedBy: [Schema!]! @relation(name: "CITED_BY", direction: OUT)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    elementOf: [Group!]! @relation(name: "ELEMENT_OF", direction: OUT)
    enteredBy: [ReferenceEnteredBy]
}

type Schema {
    pbotID: ID!
    title: String
    year: String
    cites: [Reference!]! @relation(name: "CITED_BY", direction: IN)
    characters: [Character] @relation(name: "CHARACTER_OF", direction: IN)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    appliedBy: [Description]! @relation(name: "APPLICATION_OF", direction: IN)
    elementOf: [Group!]! @relation(name: "ELEMENT_OF", direction: OUT)
    enteredBy: [SchemaEnteredBy]
}

type Character {
    pbotID: ID!
    name: String
    definition: String
    characterOfSchema: Schema! @relation(name: "CHARACTER_OF", direction: OUT)
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [CharacterInstance!]! @relation(name: "INSTANCE_OF" direction: IN)
    enteredBy: [CharacterEnteredBy]
}

type State {
    pbotID: ID!
    name: String
    definition: String
    stateOf:  Statable! @cypher(
      statement: "match (this)-[:STATE_OF]->(n) return n limit 1"
    )
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [HasState]
    enteredBy: [StateEnteredBy]
}

""" Description Complex types """
type Organ {
    pbotID: ID!
    type: String
    specimens: [Specimen!]! @relation(name: "IS_TYPE" direction: IN)
    enteredBy: [OrganEnteredBy]
}

"""Note: schema should be non null, but isn't right now due to missing data"""
type Description {
    pbotID: ID!
    type: String
	name: String
	family: String
	genus: String
	species: String
    characterInstances: [CharacterInstance!]! @relation(name: "DEFINED_BY", direction: OUT)
    candidateCharacterInstances: [CharacterInstance!]! @relation(name: "CANDIDATE_FOR", direction: IN)
    exampleSpecimens: [ExampleOf!]!
    specimen: DescribedBy
    schema: Schema @relation(name: "APPLICATION_OF", direction: OUT)
    elementOf: [Group!]! @relation(name: "ELEMENT_OF", direction: OUT)
    enteredBy: [DescriptionEnteredBy]
}

type CharacterInstance {
    pbotID: ID!
    character: Character @relation(name: "INSTANCE_OF", direction: OUT)
    state: HasState
    candidateForArchtype: Description @relation(name: "CANDIDATE_FOR", direction: OUT)
    description: Description @relation(name: "DEFINED_BY" direction: IN)
    enteredBy: [CharacterInstanceEnteredBy]
}

type Specimen {
    pbotID: ID!
    name: String
    locality: String
    preservationMode: String
    idigbiouuid: String
    pbdbcid: String
    pbdboccid: String
    organ: Organ @relation(name: "IS_TYPE", direction: OUT)
    description: DescribedBy
    archtypeDescription: ExampleOf
    elementOf: [Group!]! @relation(name: "ELEMENT_OF", direction: OUT)
    enteredBy: [SpecimenEnteredBy]
}

""" In order to access relationship properties, the relationship must be specified with a standalone type.
    Ideally, there would be one of these for the ENTERED_BY relationship, with the Enterable union in the
    from property. That does not work. So, I've had to resort to creating a separate type for each node type
    that could be in the from property. I'm not sure of the cons here. It looks like crap though. """
type GroupEnteredBy @relation(name: "ENTERED_BY") {
  from: Group
  to: Person
  timestamp: DateTime
}

type PersonEnteredBy @relation(name: "ENTERED_BY") {
  from: Person
  to: Person
  timestamp: DateTime
}

type ReferenceEnteredBy @relation(name: "ENTERED_BY") {
  from: Reference
  to: Person
  timestamp: DateTime
}

type SchemaEnteredBy @relation(name: "ENTERED_BY") {
  from: Schema
  to: Person
  timestamp: DateTime
}

type CharacterEnteredBy @relation(name: "ENTERED_BY") {
  from: Character
  to: Person
  timestamp: DateTime
}

type StateEnteredBy @relation(name: "ENTERED_BY") {
  from: State
  to: Person
  timestamp: DateTime
}

type OrganEnteredBy @relation(name: "ENTERED_BY") {
  from: Organ
  to: Person
  timestamp: DateTime
}

type DescriptionEnteredBy @relation(name: "ENTERED_BY") {
  from: Description
  to: Person
  timestamp: DateTime
}

type CharacterInstanceEnteredBy @relation(name: "ENTERED_BY") {
  from: CharacterInstance
  to: Person
  timestamp: DateTime
}

type SpecimenEnteredBy @relation(name: "ENTERED_BY") {
  from: Specimen
  to: Person
  timestamp: DateTime
}


""" HAS_STATE for access to value """
type HasState @relation(name: "HAS_STATE") {
    from: CharacterInstance
    to: State
    value: String
}


""" EXAMPLE_OF for access to entered_by and timestamp """
type ExampleOf @relation(name: "EXAMPLE_OF") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}

""" DESCRIBED_BY for access to entered_by and timestamp """
type DescribedBy @relation(name: "DESCRIBED_BY") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}



type Query {        
    """
    Not sure this will be useful, but it's a way to get at the leaf states in state hierarchies."""
    GetLeafStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                where  
                    not (n)<-[:STATE_OF]-(:State) 
                return n            
            """
        )

    GetAllStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                return n            
            """
        )
}


""" //////////////////////////////////////////////////////////////////////////////////////////////////////
Mutations overrides. We might want to think about only using these, rather than any generated mutations. 
    TODO: To make these true overrides, delete the 'Custom' prefix. """

input GroupInput {
    pbotID: String
    name: String
    members: [String]
    elements: [String]
    enteredByPersonID: String
}

input PersonInput {
    pbotID: String
    given: String
	surname: String
	email: String
	orcid: String
	groups: [String]
	enteredByPersonID: String
} 

input ReferenceInput {
    pbotID: String
    title: String
	year: String
	publisher: String
	doi: String
	authors: [String]
	groups: [String]
	enteredByPersonID: String
} 

input SchemaInput {
    pbotID: String
    title: String
	year: String
	references: [String]
	authors: [String]
	groups: [String]
	enteredByPersonID: String
	cascade: Boolean
}

input CharacterInput {
    pbotID: String
    name: String
    definition: String
    schemaID: String
	enteredByPersonID: String
	cascade: Boolean
}

input StateInput {
    pbotID: String
    name: String
    definition: String
    characterID: String
    parentStateID: String
    parentID: String
    schemaID: String
	enteredByPersonID: String
	cascade: Boolean
}

input DescriptionInput {
    pbotID: String
    type: String!
    specimenID: String
	name: String!
	family: String
	genus: String
	species: String
	schemaID: String!
	groups: [String]
	enteredByPersonID: String
	cascade: Boolean
}

input CharacterInstanceInput {
    pbotID: String
    descriptionID: String!
    characterID: String!
    stateID: String!
    quantity: String
	enteredByPersonID: String
}

input SpecimenInput {
    pbotID: String
    name: String!
    locality: String
    preservationMode: String
    idigbiouuid: String
    pbdbcid: String
    pbdboccid: String
    descriptionID: String
    otuID: String
    organID: String
	groups: [String]
	enteredByPersonID: String
}

input OrganInput {
    pbotID: String
    type: String!
	enteredByPersonID: String
}

type Mutation {
    CreateGroup(data: GroupInput!): Group! @neo4j_ignore
    UpdateGroup(data: GroupInput!): Group!  @neo4j_ignore
    DeleteGroup(data: GroupInput!): Group! @neo4j_ignore

        
    CreatePerson(data: PersonInput!): Person! @neo4j_ignore
    UpdatePerson(data: PersonInput!): Person! @neo4j_ignore
    DeletePerson(data: PersonInput!): Person! @neo4j_ignore

    CreateReference(data: ReferenceInput!): Reference! @neo4j_ignore
    UpdateReference(data: ReferenceInput!): Reference! @neo4j_ignore
    DeleteReference(data: ReferenceInput!): Reference! @neo4j_ignore

    CreateSchema(data: SchemaInput!): Schema! @neo4j_ignore
    UpdateSchema(data: SchemaInput!): Schema! @neo4j_ignore
    DeleteSchema(data: SchemaInput!): Schema! @neo4j_ignore
    
    CreateCharacter(data: CharacterInput!): Character! @neo4j_ignore
    UpdateCharacter(data: CharacterInput!): Character! @neo4j_ignore
    DeleteCharacter(data: CharacterInput!): Character! @neo4j_ignore

    CreateState(data: StateInput!): State! @neo4j_ignore
    UpdateState(data: StateInput!): State! @neo4j_ignore
    DeleteState(data: StateInput!): State! @neo4j_ignore

    CreateDescription(data: DescriptionInput!): Description! @neo4j_ignore
    UpdateDescription(data: DescriptionInput!): Description! @neo4j_ignore
    DeleteDescription(data: DescriptionInput!): Description!  @neo4j_ignore

    """NOTE: Keeping CharacterInstance create and update here rather than in Resolvers.js because of the need 
    to check that the State is associated with the Character. It's too specific to fit with the generic approach 
    of the cypher-building code in Resolvers.js. Similarly, recording the old value of HAS_STATE for a quantity
    State is also too specific."""
    CreateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (description:Description {pbotID: $data.descriptionID}),
					(description)-[:ELEMENT_OF]->(group:Group),
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
				WITH
					collect(group) AS groups, description, character, state, person
                CREATE 
                    (description)-[:DEFINED_BY]->(characterInstance:CharacterInstance {
                        pbotID: apoc.create.uuid()
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person),
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity}]-(characterInstance) 
				WITH groups, characterInstance
				FOREACH (group IN groups |
					CREATE	
						(characterInstance)-[:ELEMENT_OF]->(group)
                )
                RETURN characterInstance
            """
        )
    UpdateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance! 
        @cypher(
            statement: """
                MATCH 
                    (characterInstance:CharacterInstance {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                WITH characterInstance, ePerson					
				CREATE
					(characterInstance)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
				WITH characterInstance, eb
                OPTIONAL MATCH
					(oldCharacter:Character)<-[oldCharacterRelationship:INSTANCE_OF]-(characterInstance)
				DELETE oldCharacterRelationship
                WITH characterInstance, eb, oldCharacter					
                    CALL apoc.do.case([
                            oldCharacter IS NULL AND $data.characterID IS NOT NULL,
                            "SET eb.character = 'not present' RETURN eb",
                            oldCharacter IS NOT NULL AND ($data.characterID IS NULL OR oldCharacter.pbotID  <> $data.characterID),
                            "SET eb.character = oldCharacter.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldCharacter: oldCharacter, eb: eb}
                        ) YIELD value
                WITH characterInstance, eb					
                OPTIONAL MATCH
					(oldState:State)<-[oldStateRelationship:HAS_STATE]-(characterInstance)
                WITH characterInstance, eb, oldState, oldStateRelationship				
                    CALL apoc.do.case([
                            oldState IS NULL AND $data.stateID IS NOT NULL,
                            "SET eb.state = 'not present' RETURN eb",
                            oldState IS NOT NULL AND ($data.stateID IS NULL OR oldState.pbotID  <> $data.stateID OR oldStateRelationship.value <> $data.quantity),
                            "SET eb.state = oldState.pbotID, eb.value = oldStateRelationship.value RETURN eb"],
                            "RETURN eb",
                            {oldState: oldState, oldStateRelationship: oldStateRelationship, eb: eb}
                        ) YIELD value
                        DELETE oldStateRelationship
				WITH characterInstance
				MATCH
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID})
                CREATE 
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity}]-(characterInstance) 
                RETURN characterInstance
            """
        )
    DeleteCharacterInstance(data: CharacterInstanceInput!): CharacterInstance! @neo4j_ignore

    CreateSpecimen(data: SpecimenInput!): Specimen! @neo4j_ignore
    UpdateSpecimen(data: SpecimenInput!): Specimen! @neo4j_ignore
    DeleteSpecimen(data: SpecimenInput!): Specimen! @neo4j_ignore

    CreateOrgan(data: OrganInput!): Organ! @neo4j_ignore
    UpdateOrgan(data: OrganInput!): Organ! @neo4j_ignore
    DeleteOrgan(data: OrganInput!): Organ! @neo4j_ignore

}
