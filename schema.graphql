scalar DateTime

""" These unions are a way for a property to hold references to different types """
union Enterable = Person | Reference | Schema | Character | State

union Authorable = Reference | Schema

union Statable = Character | State

""" Note that I had to use the cypher directive to populate the entered property.
    Ideally, this would be handled by a relation directive, but that does not appear to
    work with unions. """
type Person {
    pbotID: ID!
    given: String
    surname: String
    email: String
    orcid: String
    entered:   [Enterable] @cypher(
      statement: "match (n)-[:ENTERED_BY]->(this) return n"
    )
    authored: [Authorable!]! @relation(name: "AUTHORED_BY", direction: IN)
}

type Reference {
    pbotID: ID!
    title: String
    year: String
    publisher: String
    doi: String
    citedBy: [Schema!]! @relation(name: "CITED_BY", direction: OUT)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    enteredBy: [ReferenceEnteredBy]
}

type Schema {
    pbotID: ID!
    title: String
    year: String
    cites: [Reference!]! @relation(name: "CITED_BY", direction: IN)
    characters: [Character] @relation(name: "CHARACTER_OF", direction: IN)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    appliedBy: [Description]! @relation(name: "APPLICATION_OF", direction: IN)
    enteredBy: [SchemaEnteredBy]
}

type Character {
    pbotID: ID!
    name: String
    definition: String
    characterOfSchema: Schema! @relation(name: "CHARACTER_OF", direction: OUT)
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [CharacterInstance!]! @relation(name: "INSTANCE_OF" direction: IN)
    enteredBy: [CharacterEnteredBy]
}

type State {
    pbotID: ID!
    name: String
    definition: String
    stateOf:  Statable! @cypher(
      statement: "match (this)-[:STATE_OF]->(n) return n limit 1"
    )
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [HasState]
    enteredBy: [StateEnteredBy]
}

""" Description Complex types """
type Organ {
    pbotID: ID!
    type: String
    specimens: [Specimen!]! @relation(name: "IS_TYPE" direction: IN)
    enteredBy: [OrganEnteredBy]
}

"""Note: schema should be non null, but isn't right now due to missing data"""
type Description {
    pbotID: ID!
    type: String
	name: String
	family: String
	genus: String
	species: String
    characterInstances: [CharacterInstance!]! @relation(name: "DEFINED_BY", direction: OUT)
    candidateCharacterInstances: [CharacterInstance!]! @relation(name: "CANDIDATE_FOR", direction: IN)
    exampleSpecimens: [ExampleOf!]!
    specimen: DescribedBy
    schema: Schema @relation(name: "APPLICATION_OF", direction: OUT)
    enteredBy: [DescriptionEnteredBy]
}

type CharacterInstance {
    pbotID: ID!
    character: Character @relation(name: "INSTANCE_OF", direction: OUT)
    state: HasState
    candidateForArchtype: Description @relation(name: "CANDIDATE_FOR", direction: OUT)
    description: Description @relation(name: "DEFINED_BY" direction: IN)
    enteredBy: [CharacterInstanceEnteredBy]
}

type Specimen {
    pbotID: ID!
    name: String
    locality: String
    organ: Organ @relation(name: "IS_TYPE", direction: OUT)
    description: DescribedBy
    archtypeDescription: ExampleOf
    enteredBy: [SpecimenEnteredBy]
}

""" In order to access relationship properties, the relationship must be specified with a standalone type.
    Ideally, there would be one of these for the ENTERED_BY relationship, with the Enterable union in the
    from property. That does not work. So, I've had to resort to creating a separate type for each node type
    that could be in the from property. I'm not sure of the cons here. It looks like crap though. """
type ReferenceEnteredBy @relation(name: "ENTERED_BY") {
  from: Reference
  to: Person
  timestamp: DateTime
}

type SchemaEnteredBy @relation(name: "ENTERED_BY") {
  from: Schema
  to: Person
  timestamp: DateTime
}

type CharacterEnteredBy @relation(name: "ENTERED_BY") {
  from: Character
  to: Person
  timestamp: DateTime
}

type StateEnteredBy @relation(name: "ENTERED_BY") {
  from: State
  to: Person
  timestamp: DateTime
}

type OrganEnteredBy @relation(name: "ENTERED_BY") {
  from: Organ
  to: Person
  timestamp: DateTime
}

type DescriptionEnteredBy @relation(name: "ENTERED_BY") {
  from: Description
  to: Person
  timestamp: DateTime
}

type CharacterInstanceEnteredBy @relation(name: "ENTERED_BY") {
  from: CharacterInstance
  to: Person
  timestamp: DateTime
}

type SpecimenEnteredBy @relation(name: "ENTERED_BY") {
  from: Specimen
  to: Person
  timestamp: DateTime
}


""" HAS_STATE for access to value """
type HasState @relation(name: "HAS_STATE") {
    from: CharacterInstance
    to: State
    value: String
}


""" EXAMPLE_OF for access to entered_by and timestamp """
type ExampleOf @relation(name: "EXAMPLE_OF") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}

""" DESCRIBED_BY for access to entered_by and timestamp """
type DescribedBy @relation(name: "DESCRIBED_BY") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}



"""
Not sure this will be useful, but it's a way to get at the leaf states in state hierarchies."""
type Query {
    GetLeafStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                where  
                    not (n)<-[:STATE_OF]-(:State) 
                return n            
            """
        )

    GetAllStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                return n            
            """
        )
}


""" //////////////////////////////////////////////////////////////////////////////////////////////////////
Mutations overrides. We might want to think about only using these, rather than any generated mutations. 
    TODO: To make these true overrides, delete the 'Custom' prefix. """

input PersonInput {
    pbotID: String
    given: String
	surname: String
	email: String
	orcid: String
	enteredByPersonID: String
} 

input ReferenceInput {
    pbotID: String
    title: String
	year: String
	publisher: String
	doi: String
	authors: [String]
	enteredByPersonID: String
} 

input SchemaInput {
    pbotID: String
    title: String
	year: String
	references: [String]
	authors: [String]
	enteredByPersonID: String
}

input CharacterInput {
    pbotID: String
    name: String
    definition: String
    schemaID: String
	enteredByPersonID: String
}

input StateInput {
    pbotID: String
    name: String
    definition: String
    characterID: String
    parentStateID: String
	enteredByPersonID: String
}

input DescriptionInput {
    pbotID: String
    type: String!
    specimenID: String
	name: String!
	family: String
	genus: String
	species: String
	schemaID: String!
	enteredByPersonID: String
}

input CharacterInstanceInput {
    pbotID: String
    descriptionID: String!
    characterID: String!
    stateID: String!
    quantity: String
	enteredByPersonID: String
}

input SpecimenInput {
    pbotID: String
    name: String!
    locality: String
    preservationMode: String
    idigbiouuid: String
    pbdbcid: String
    pbdboccid: String
    descriptionID: String
    otuID: String
    organID: String
	enteredByPersonID: String
}

input OrganInput {
    pbotID: String
    type: String!
	enteredByPersonID: String
}

type Mutation {
    CustomCreatePerson(data: PersonInput!): Person!
        @cypher(
            statement: """
                MATCH 
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (person: Person {
                        pbotID: apoc.create.uuid(),
                        given: $data.given,
                        surname: $data.surname,
                        email: $data.email,
                        orcid: $data.orcid
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(ePerson)
                RETURN person
            """
        )

    CustomUpdatePerson(data: PersonInput!): Person!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                CREATE
                    (person)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH person, eb
                    CALL apoc.do.case([
                        person.given IS NULL AND $data.given IS NOT NULL,
                        "SET eb.given = 'not present' RETURN eb",
                        person.given IS NOT NULL AND ($data.given IS NULL OR person.given <> $data.given), 
                        "SET eb.given = person.given RETURN eb"],
                        "RETURN eb",
                        {person: person, eb:eb}
                    ) YIELD value
                WITH person, value.eb AS eb
                    CALL apoc.do.case([
                        person.surname IS NULL AND $data.surname IS NOT NULL,
                        "SET eb.surname = 'not present' RETURN eb",
                        person.surname IS NOT NULL AND ($data.surname IS NULL OR person.surname <> $data.surname), 
                        "SET eb.surname = person.surname RETURN eb"],
                        "RETURN eb",
                        {person: person, eb:eb}
                    ) YIELD value
                WITH person, value.eb AS eb
                    CALL apoc.do.case([
                        person.email IS NULL AND $data.email IS NOT NULL,
                        "SET eb.email = 'not present' RETURN eb",
                        person.email IS NOT NULL AND ($data.email IS NULL OR person.email <> $data.email), 
                        "SET eb.email = person.email RETURN eb"],
                        "RETURN eb",
                        {person: person, eb:eb}
                    ) YIELD value
                WITH person, value.eb AS eb
                    CALL apoc.do.case([
                        person.orcid IS NULL AND $data.orcid IS NOT NULL,
                        "SET eb.orcid = 'not present' RETURN eb",
                        person.orcid IS NOT NULL AND ($data.orcid IS NULL OR person.orcid <> $data.orcid), 
                        "SET eb.orcid = person.orcid RETURN eb"],
                        "RETURN eb",
                        {person: person, eb:eb}
                    ) YIELD value
                WITH person
                SET 
                    person.given = $data.given,
                    person.surname = $data.surname,
                    person.email = $data.email,
                    person.orcid = $data.orcid
                RETURN person
            """
        )


    CustomCreateReference(data: ReferenceInput!): Reference!
    @cypher(
        statement: """
            MATCH 
                (person:Person {pbotID: $data.enteredByPersonID})
            CREATE 
                (reference: Reference {
                    pbotID: apoc.create.uuid(),
                    title: $data.title,
                    year: $data.year,
                    publisher: $data.publisher,
                    doi: $data.doi
                })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
            WITH reference
            UNWIND $data.authors AS aID
                MATCH (author:Person {pbotID: aID}) 
                CREATE (reference)-[:AUTHORED_BY]->(author)
            RETURN reference
        """
    )

    CustomUpdateReference(data: ReferenceInput!): Reference!
        @cypher(
            statement: """
                MATCH 
					(reference:Reference {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                WITH reference, ePerson					
				CREATE
					(reference)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH reference, eb
                    CALL apoc.do.case([
                        reference.title IS NULL AND $data.title IS NOT NULL,
                        "SET eb.title = 'not present' RETURN eb",
                        reference.title IS NOT NULL AND ($data.title IS NULL OR reference.title <> $data.title), 
                        "SET eb.title = reference.title RETURN eb"],
                        "RETURN eb",
                        {reference: reference, eb:eb}
                    ) YIELD value
                WITH reference, value.eb AS eb
                    CALL apoc.do.case([
                        reference.year IS NULL AND $data.year IS NOT NULL,
                        "SET eb.year = 'not present' RETURN eb",
                        reference.year IS NOT NULL AND ($data.year IS NULL OR reference.year <> $data.year), 
                        "SET eb.year = reference.year RETURN eb"],
                        "RETURN eb",
                        {reference: reference, eb:eb}
                    ) YIELD value
                WITH reference, value.eb AS eb
                    CALL apoc.do.case([
                        reference.publisher IS NULL AND $data.publisher IS NOT NULL,
                        "SET eb.publisher = 'not present' RETURN eb",
                        reference.publisher IS NOT NULL AND ($data.publisher IS NULL OR reference.publisher <> $data.publisher), 
                        "SET eb.publisher = reference.publisher RETURN eb"],
                        "RETURN eb",
                        {reference: reference, eb:eb}
                    ) YIELD value
                WITH reference, value.eb AS eb
                    CALL apoc.do.case([
                        reference.doi IS NULL AND $data.doi IS NOT NULL,
                        "SET eb.doi = 'not present' RETURN eb",
                        reference.doi IS NOT NULL AND ($data.doi IS NULL OR reference.doi <> $data.doi), 
                        "SET eb.doi = reference.doi RETURN eb"],
                        "RETURN eb",
                        {reference: reference, eb:eb}
                    ) YIELD value
                WITH reference, value.eb AS eb
                OPTIONAL MATCH
					(person:Person)<-[oldAuthorRelationship:AUTHORED_BY]-(reference)
                WITH 
                    collect(person.pbotID) as oldAuthors, collect(oldAuthorRelationship) AS oars, reference, eb
                UNWIND oars AS ar
                    DELETE ar
                WITH collect(ar) as dummy, oldAuthors, reference, apoc.coll.disjunction(oldAuthors, $data.authors ) AS diffList, eb
                CALL
                    apoc.do.when(
                        SIZE(diffList)<>0,
                        "SET eb.authors = oldAuthors RETURN eb",
                        "RETURN eb",
                        {diffList: diffList, oldAuthors: oldAuthors, eb: eb}
                    )
                YIELD value
                WITH reference
                SET 
                    reference.title = $data.title,
                    reference.year = $data.year,
                    reference.publisher = $data.publisher,
                    reference.doi = $data.doi
                WITH reference
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (reference)-[:AUTHORED_BY]->(author)
                WITH collect(aID) as dummy, reference
                RETURN reference
            """
        )
        
    CustomDeleteReference(data: ReferenceInput!): Reference! @neo4j_ignore

    CustomCreateSchema(data: SchemaInput!): Schema!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (schema:Schema {
                        pbotID: apoc.create.uuid(),
                        title: $data.title,
                        year: $data.year
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH schema
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (schema)-[:AUTHORED_BY]->(author)
                WITH collect(aID) as dummy, schema
                UNWIND $data.references as rID
                    MATCH (reference:Reference {pbotID: rID})
                    CREATE (reference)-[:CITED_BY]->(schema)
                WITH collect(rID)as dummy, schema
                RETURN schema
            """
        )

    CustomUpdateSchema(data: SchemaInput!): Schema!
        @cypher(
            statement: """
                MATCH 
					(schema:Schema {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
				WITH schema, ePerson
				CREATE
					(schema)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH schema, eb
                    CALL apoc.do.case([
                        schema.title IS NULL AND $data.title IS NOT NULL,
                        "SET eb.title = 'not present' RETURN eb",
                        schema.title IS NOT NULL AND ($data.title IS NULL OR schema.title <> $data.title), 
                        "SET eb.title = schema.title RETURN eb"],
                        "RETURN eb",
                        {schema: schema, eb:eb}
                    ) YIELD value
                WITH schema, value.eb AS eb
                    CALL apoc.do.case([
                        schema.year IS NULL AND $data.year IS NOT NULL,
                        "SET eb.year = 'not present' RETURN eb",
                        schema.year IS NOT NULL AND ($data.year IS NULL OR schema.year <> $data.year), 
                        "SET eb.year = schema.year RETURN eb"],
                        "RETURN eb",
                        {schema: schema, eb:eb}
                    ) YIELD value
                OPTIONAL MATCH
					(reference:Reference)-[oldCitationRelationship:CITED_BY]->(schema)
                WITH schema, eb, collect(reference.pbotID) AS oldRefs, collect(oldCitationRelationship) AS ocrs
                UNWIND ocrs AS cr
                    DELETE cr
                WITH collect(cr) as dummy, schema, oldRefs, apoc.coll.disjunction(oldRefs, $data.references ) AS diffList, eb
                CALL
                    apoc.do.when(
                        SIZE(diffList)<>0,
                        "SET eb.references = oldRefs RETURN eb",
                        "RETURN eb",
                        {diffList: diffList, oldRefs: oldRefs, eb: eb}
                    )
                YIELD value
				WITH schema, eb
                OPTIONAL MATCH
					(person:Person)<-[oldAuthorRelationship:AUTHORED_BY]-(schema)
                WITH schema, eb, collect(person.pbotID) as oldAuthors, collect(oldAuthorRelationship) AS oars
                UNWIND oars AS ar
                    DELETE ar
                WITH collect(ar) as dummy, schema, oldAuthors, apoc.coll.disjunction(oldAuthors, $data.authors ) AS diffList, eb
                CALL
                    apoc.do.when(
                        SIZE(diffList)<>0,
                        "SET eb.authors = oldAuthors RETURN eb",
                        "RETURN eb",
                        {diffList: diffList, oldAuthors: oldAuthors, eb: eb}
                    )
                YIELD value
				WITH schema
                SET 
                    schema.title = $data.title,
                    schema.year = $data.year
                WITH schema
                UNWIND $data.references AS rID
                    MATCH (reference:Reference {pbotID: rID}) 
                    CREATE (reference)-[:CITED_BY]->(schema)
                WITH collect(rID) AS dummy, schema
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (schema)-[:AUTHORED_BY]->(author)
                WITH collect (aID) as dummy, schema
                RETURN schema
            """
        )
        
    CustomDeleteSchema(data: SchemaInput!): Schema! @neo4j_ignore
    

    CustomCreateCharacter(data: CharacterInput!): Character!
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (schema)<-[:CHARACTER_OF]-(character:Character {
                        pbotID: apoc.create.uuid(),
                        name: $data.name,
                        definition: $data.definition
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                RETURN character
            """
        )

    CustomUpdateCharacter(data: CharacterInput!): Character!
        @cypher(
            statement: """
                MATCH 
					(character:Character {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                WITH character, ePerson					
				CREATE
					(character)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH character, eb
                    CALL apoc.do.case([
                        character.name IS NULL AND $data.name IS NOT NULL,
                        "SET eb.name = 'not present' RETURN eb",
                        character.name IS NOT NULL AND ($data.name IS NULL OR character.name <> $data.name), 
                        "SET eb.name = character.name RETURN eb"],
                        "RETURN eb",
                        {character: character, eb:eb}
                    ) YIELD value
                WITH character, value.eb AS eb
                    CALL apoc.do.case([
                        character.definition IS NULL AND $data.definition IS NOT NULL,
                        "SET eb.definition = 'not present' RETURN eb",
                        character.definition IS NOT NULL AND ($data.definition IS NULL OR character.definition <> $data.definition), 
                        "SET eb.definition = character.definition RETURN eb"],
                        "RETURN eb",
                        {character: character, eb:eb}
                    ) YIELD value
				WITH character
                SET 
                    character.name = $data.name,
                    character.definition = $data.definition
                RETURN character
            """
        )
        
    CustomDeleteCharacter(data: CharacterInput!): Character! @neo4j_ignore

    CustomCreateState(data: StateInput!): State!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CALL apoc.case([
                    $data.parentStateID is null, "MATCH (parent:Character {pbotID: characterID}) RETURN parent",
                    $data.parentStateID is not null, "MATCH (parent:State {pbotID: parentStateID}) RETURN parent"],
                    'RETURN "" as parent',
                    {characterID: $data.characterID, parentStateID: $data.parentStateID}
                ) YIELD value 
                WITH value.parent as parent, person
                    CREATE 
                        (parent)<-[:STATE_OF]-(state:State {
                            pbotID: apoc.create.uuid(),
                            name: $data.name,
                            definition:$data.definition
                        })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                    RETURN state           
            """
        )

    CustomUpdateState(data: StateInput!): State!
        @cypher(
            statement: """
                MATCH 
					(state:State {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
				CREATE
					(state)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH state, eb
                    CALL apoc.do.case([
                        state.name IS NULL AND $data.name IS NOT NULL,
                        "SET eb.name = 'not present' RETURN eb",
                        state.name IS NOT NULL AND ($data.name IS NULL OR state.name <> $data.name), 
                        "SET eb.name = state.name RETURN eb"],
                        "RETURN eb",
                        {state: state, eb:eb}
                    ) YIELD value
                WITH state, value.eb AS eb
                    CALL apoc.do.case([
                        state.definition IS NULL AND $data.definition IS NOT NULL,
                        "SET eb.definition = 'not present' RETURN eb",
                        state.definition IS NOT NULL AND ($data.definition IS NULL OR state.definition <> $data.definition), 
                        "SET eb.definition = state.definition RETURN eb"],
                        "RETURN eb",
                        {state: state, eb:eb}
                    ) YIELD value
				WITH state, eb
                OPTIONAL MATCH
					(oldParent)<-[oldParentRelationship:STATE_OF]-(state)
				DELETE oldParentRelationship
                WITH state, eb, oldParent
                CALL apoc.case([
                    $data.parentStateID is null and $data.characterID is not null, 
                    "MATCH (parent:Character {pbotID: characterID}) RETURN parent",
                    $data.parentStateID is not null, 
                    "MATCH (parent:State {pbotID: parentStateID}) RETURN parent"],
                    'RETURN null as parent',
                    {characterID: $data.characterID, parentStateID: $data.parentStateID}
                ) YIELD value 
                WITH value.parent as parent, state, oldParent, eb
                    CALL apoc.do.case([
                            oldParent IS NULL AND parent IS NOT NULL,
                            "SET eb.parent = 'not present' RETURN eb",
                            oldParent IS NOT NULL AND (parent IS NULL OR oldParent.pbotID  <> parent.pbotID),
                            "SET eb.parent = oldParent.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldParent: oldParent, eb: eb}
                        ) YIELD value
				WITH state, parent
                SET 
                    state.name = $data.name,
                    state.definition = $data.definition
                CREATE
                    (state)-[:STATE_OF]->(parent)
                RETURN state           
            """
        )
        
    CustomDeleteState(data: StateInput!): State! @neo4j_ignore

    CustomCreateDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
                    (specimen:Specimen {pbotID: $data.specimenID})
                CREATE 
                    (schema)<-[:APPLICATION_OF]-(description: Description {
                        pbotID: apoc.create.uuid(),
                        type: $data.type,
                        name: $data.name,
                        family: $data.family,
                        genus: $data.genus,
                        species: $data.species
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH description, specimen
                CALL apoc.do.when(
                    specimen is not null, 
                    "CREATE (specimen)-[:DESCRIBED_BY]->(description) RETURN description", 
                    'RETURN description',
                    {specimen: specimen, description: description}
                ) YIELD value
                RETURN value.description AS description                
            """
        )

    CustomUpdateDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
					(description:Description {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
				CREATE
					(description)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH description, eb
                    CALL apoc.do.case([
                        description.type IS NULL AND $data.type IS NOT NULL,
                        "SET eb.type = 'not present' RETURN eb",
                        description.type IS NOT NULL AND ($data.type IS NULL OR description.type <> $data.type), 
                        "SET eb.type = description.type RETURN eb"],
                        "RETURN eb",
                        {description: description, eb:eb}
                    ) YIELD value
                WITH description, value.eb AS eb
                    CALL apoc.do.case([
                        description.name IS NULL AND $data.name IS NOT NULL,
                        "SET eb.name = 'not present' RETURN eb",
                        description.name IS NOT NULL AND ($data.name IS NULL OR description.name <> $data.name), 
                        "SET eb.name = description.name RETURN eb"],
                        "RETURN eb",
                        {description: description, eb:eb}
                    ) YIELD value
                WITH description, value.eb AS eb
                    CALL apoc.do.case([
                        description.family IS NULL AND $data.family IS NOT NULL,
                        "SET eb.family = 'not present' RETURN eb",
                        description.family IS NOT NULL AND ($data.family IS NULL OR description.family <> $data.family), 
                        "SET eb.family = description.family RETURN eb"],
                        "RETURN eb",
                        {description: description, eb:eb}
                    ) YIELD value
                WITH description, value.eb AS eb
                    CALL apoc.do.case([
                        description.genus IS NULL AND $data.genus IS NOT NULL,
                        "SET eb.genus = 'not present' RETURN eb",
                        description.genus IS NOT NULL AND ($data.genus IS NULL OR description.genus <> $data.genus), 
                        "SET eb.genus = description.genus RETURN eb"],
                        "RETURN eb",
                        {description: description, eb:eb}
                    ) YIELD value
                WITH description, value.eb AS eb
                    CALL apoc.do.case([
                        description.species IS NULL AND $data.species IS NOT NULL,
                        "SET eb.species = 'not present' RETURN eb",
                        description.species IS NOT NULL AND ($data.species IS NULL OR description.species <> $data.species), 
                        "SET eb.species = description.species RETURN eb"],
                        "RETURN eb",
                        {description: description, eb:eb}
                    ) YIELD value
                WITH description, value.eb AS eb
                OPTIONAL MATCH
					(oldSchema:Schema)<-[oldSchemaRelationship:APPLICATION_OF]-(description)
				DELETE oldSchemaRelationship
                WITH description, eb, oldSchema
                    CALL apoc.do.case([
                            oldSchema IS NULL AND $data.schemaID IS NOT NULL,
                            "SET eb.schema = 'not present' RETURN eb",
                            oldSchema IS NOT NULL AND ($data.schemaID IS NULL OR oldSchema.pbotID  <> $data.schemaID),
                            "SET eb.schema = oldSchema.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldSchema: oldSchema, eb: eb}
                        ) YIELD value
                OPTIONAL MATCH
					(oldSpecimen:Specimen)-[oldSpecimenRelationship:DESCRIBED_BY]->(description)
				DELETE oldSpecimenRelationship
				WITH description, value.eb as eb, oldSpecimen 	
                    CALL apoc.do.case([
                            oldSpecimen IS NULL AND $data.specimenID IS NOT NULL,
                            "SET eb.specimen = 'not present' RETURN eb",
                            oldSpecimen IS NOT NULL AND ($data.specimenID IS NULL OR oldSpecimen.pbotID  <> $data.specimenID),
                            "SET eb.specimen = oldSpecimen.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldSpecimen: oldSpecimen, eb: eb}
                        ) YIELD value
				WITH description	
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID})
				SET
					description.type = $data.type,
					description.name = $data.name,
					description.family = $data.family,
					description.genus = $data.genus,
					description.species = $data.species
                CREATE 
                    (schema)<-[:APPLICATION_OF]-(description)
				WITH description 
                OPTIONAL MATCH
                    (specimen:Specimen {pbotID: $data.specimenID})
                WITH description, specimen
                CALL apoc.do.when(
                    specimen is not null, 
                    'CREATE (specimen)-[:DESCRIBED_BY]->(description) RETURN description', 
                    'RETURN description',
                    {specimen: specimen, description: description}
                ) YIELD value
                RETURN value.description AS description                
            """
        )
        
    """NOTE: For now, only allowing delete of nodes entered by same user. Will likely need further logic here.
    ALSO NOTE: Error reporting is not the best here. I had tried to use apoc.do.when to check for DEFINED_BY before deleting, but
    it seems that routine only accepts one relationship of a type at a time, so can't UNWIND within it. Instead, I'm just ignoring
    DEFINED_BY ad letting cypher catch the problem and rollback the operation. But this results in less than ideal error messaging to the client."""
    CustomDeleteDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
                    (description:Description {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(person:Person {pbotID:$data.enteredByPersonID})
                OPTIONAL MATCH
                    (description)-[applicationOf:APPLICATION_OF]->(:Schema)
                OPTIONAL MATCH
                    (description)<-[describedBy:DESCRIBED_BY]-(:Specimen)
                WITH enteredBy, applicationOf, describedBy, description
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, applicationOf, describedBy, description 
                    DELETE applicationOf, describedBy 
                WITH description, description.pbotID AS dID
                    DELETE description
                WITH {
                    pbotID: dID + " deleted"
                } AS result
                RETURN result
            """
        )

    """NOTE: No when is needed for the HAS_STATE value property below since setting properties to null 
    means they don't exist."""
    CustomCreateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (description:Description {pbotID: $data.descriptionID}),
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (description)-[:DEFINED_BY]->(characterInstance:CharacterInstance {
                        pbotID: apoc.create.uuid()
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person),
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity, type:"CREATE"}]-(characterInstance) 
                RETURN characterInstance
            """
        )

    CustomUpdateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (characterInstance:CharacterInstance {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                WITH characterInstance, ePerson					
				CREATE
					(characterInstance)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
				WITH characterInstance, eb
                OPTIONAL MATCH
					(oldCharacter:Character)<-[oldCharacterRelationship:INSTANCE_OF]-(characterInstance)
				DELETE oldCharacterRelationship
                WITH characterInstance, eb, oldCharacter					
                    CALL apoc.do.case([
                            oldCharacter IS NULL AND $data.characterID IS NOT NULL,
                            "SET eb.character = 'not present' RETURN eb",
                            oldCharacter IS NOT NULL AND ($data.characterID IS NULL OR oldCharacter.pbotID  <> $data.characterID),
                            "SET eb.character = oldCharacter.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldCharacter: oldCharacter, eb: eb}
                        ) YIELD value
                WITH characterInstance, eb					
                OPTIONAL MATCH
					(oldState:State)<-[oldStateRelationship:HAS_STATE]-(characterInstance)
                DELETE oldStateRelationship
                WITH characterInstance, eb, oldState				
                    CALL apoc.do.case([
                            oldState IS NULL AND $data.stateID IS NOT NULL,
                            "SET eb.state = 'not present' RETURN eb",
                            oldState IS NOT NULL AND ($data.stateID IS NULL OR oldState.pbotID  <> $data.stateID),
                            "SET eb.state = oldState.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldState: oldState, eb: eb}
                        ) YIELD value
				WITH characterInstance
				MATCH
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID})
                CREATE 
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity}]-(characterInstance) 
                RETURN characterInstance
            """
        )

    CustomDeleteCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (characterInstance:CharacterInstance {pbotID: $data.pbotID})-[:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                WITH characterInstance, characterInstance.pbotID AS cIID
                    DETACH DELETE characterInstance
                WITH {
                    pbotID: cIID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID}),
                    (organ:Organ {pbotID: $data.organID})
                OPTIONAL MATCH
                    (description:Description {pbotID: $data.descriptionID})
                OPTIONAL MATCH
                    (otu:Description {pbotID: $data.otuID})
                CREATE
                    (organ)<-[:IS_TYPE]-(specimen:Specimen {
                        pbotID: apoc.create.uuid(),
                        name: $data.name,
                        locality: $data.locality,
                        preservationMode: $data.preservationMode,
                        idigbiouuid: $data.idigbiouuid,
                        pbdbcid: $data.pbdbcid,
                        pbdboccid: $data.pbdboccid
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH specimen, description, otu
                    CALL apoc.do.when(
                        description IS NOT NULL,
                        "CREATE (description)<-[:DESCRIBED_BY]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {description: description, specimen: specimen}) YIELD value
                    WITH value.specimen AS specimen, otu
                    CALL apoc.do.when(
                        otu IS NOT NULL,
                        "CREATE (otu)<-[:EXAMPLE_OF]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {otu: otu, specimen: specimen}) YIELD value
                RETURN value.specimen as specimen           
            """
        )

    CustomUpdateSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
                MATCH 
					(specimen:Specimen {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                WITH specimen, ePerson					
				CREATE
					(specimen)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH specimen, eb
                    CALL apoc.do.case([
                        specimen.name IS NULL AND $data.name IS NOT NULL,
                        "SET eb.name = 'not present' RETURN eb",
                        specimen.name IS NOT NULL AND ($data.name IS NULL OR specimen.name <> $data.name), 
                        "SET eb.name = specimen.name RETURN eb"],
                        "RETURN eb",
                        {specimen: specimen, eb:eb}
                    ) YIELD value
                WITH specimen, value.eb AS eb
                    CALL apoc.do.case([
                        specimen.locality IS NULL AND $data.locality IS NOT NULL,
                        "SET eb.locality = 'not present' RETURN eb",
                        specimen.locality IS NOT NULL AND ($data.locality IS NULL OR specimen.locality <> $data.locality), 
                        "SET eb.locality = specimen.locality RETURN eb"],
                        "RETURN eb",
                        {specimen: specimen, eb:eb}
                    ) YIELD value
                WITH specimen, value.eb AS eb
                    CALL apoc.do.case([
                        specimen.preservationMode IS NULL AND $data.preservationMode IS NOT NULL,
                        "SET eb.preservationMode = 'not present' RETURN eb",
                        specimen.preservationMode IS NOT NULL AND ($data.preservationMode IS NULL OR specimen.preservationMode <> $data.preservationMode), 
                        "SET eb.preservationMode = specimen.preservationMode RETURN eb"],
                        "RETURN eb",
                        {specimen: specimen, eb:eb}
                    ) YIELD value
                WITH specimen, value.eb AS eb
                    CALL apoc.do.case([
                        specimen.idigbiouuid IS NULL AND $data.idigbiouuid IS NOT NULL,
                        "SET eb.idigbiouuid = 'not present' RETURN eb",
                        specimen.idigbiouuid IS NOT NULL AND ($data.idigbiouuid IS NULL OR specimen.idigbiouuid <> $data.idigbiouuid), 
                        "SET eb.idigbiouuid = specimen.idigbiouuid RETURN eb"],
                        "RETURN eb",
                        {specimen: specimen, eb:eb}
                    ) YIELD value
                WITH specimen, value.eb AS eb
                    CALL apoc.do.case([
                        specimen.pbdbcid IS NULL AND $data.pbdbcid IS NOT NULL,
                        "SET eb.pbdbcid = 'not present' RETURN eb",
                        specimen.pbdbcid IS NOT NULL AND ($data.pbdbcid IS NULL OR specimen.pbdbcid <> $data.pbdbcid), 
                        "SET eb.pbdbcid = specimen.pbdbcid RETURN eb"],
                        "RETURN eb",
                        {specimen: specimen, eb:eb}
                    ) YIELD value
                WITH specimen, value.eb AS eb
                    CALL apoc.do.case([
                        specimen.pbdboccid IS NULL AND $data.pbdboccid IS NOT NULL,
                        "SET eb.pbdboccid = 'not present' RETURN eb",
                        specimen.pbdboccid IS NOT NULL AND ($data.pbdboccid IS NULL OR specimen.pbdboccid <> $data.pbdboccid), 
                        "SET eb.pbdboccid = specimen.pbdboccid RETURN eb"],
                        "RETURN eb",
                        {specimen: specimen, eb:eb}
                    ) YIELD value
                WITH specimen, value.eb AS eb
                OPTIONAL MATCH
					(specimen)-[oldDescribedByRelationship:DESCRIBED_BY]->(oldDBDesc:Description)
				DELETE oldDescribedByRelationship
                WITH specimen, eb, oldDBDesc					
                    CALL
                        apoc.do.case([
                            oldDBDesc IS NULL AND $data.descriptionID IS NOT NULL,
                            "SET eb.description = 'not present' RETURN eb",
                            oldDBDesc IS NOT NULL AND ($data.descriptionID IS NULL OR oldDBDesc.pbotID  <> $data.descriptionID),
                            "SET eb.description = oldDBDesc.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldDBDesc: oldDBDesc, eb: eb}
                        ) YIELD value
				WITH specimen, eb	
                OPTIONAL MATCH
					(specimen)-[oldExampleOfRelationship:EXAMPLE_OF]->(oldERDesc:Description)
				DELETE oldExampleOfRelationship
                WITH specimen, eb, oldERDesc					
                    CALL
                        apoc.do.case([
                            oldERDesc IS NULL AND $data.otuID IS NOT NULL,
                            "SET eb.archtypeDescription = 'not present' RETURN eb",
                            oldERDesc IS NOT NULL AND ($data.otuID IS NULL OR oldERDesc.pbotID  <> $data.otuID),
                            "SET eb.archtypeDescription = oldERDesc.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldERDesc: oldERDesc, eb: eb}
                        ) YIELD value
				WITH specimen, eb	
                MATCH
					(specimen)-[oldOrganRelationship:IS_TYPE]->(oldOrgan:Organ)
				DELETE oldOrganRelationship
                WITH specimen, eb, oldOrgan					
                    CALL
                        apoc.do.case([
                            oldOrgan IS NULL AND $data.organID IS NOT NULL,
                            "SET eb.organ = 'not present' RETURN eb",
                            oldOrgan IS NOT NULL AND ($data.organID IS NULL OR oldOrgan.pbotID  <> $data.organID),
                            "SET eb.organ = oldOrgan.pbotID RETURN eb"],
                            "RETURN eb",
                            {oldOrgan: oldOrgan, eb: eb}
                        ) YIELD value
				WITH specimen	
				SET
                    specimen.name = $data.name,
                    specimen.locality = $data.locality,
                    specimen.preservationMode = $data.preservationMode,
                    specimen.idigbiouuid = $data.idigbiouuid,
                    specimen.pbdbcid = $data.pbdbcid,
                    specimen.pbdboccid = $data.pbdboccid
                WITH specimen
				MATCH	
                    (organ:Organ {pbotID: $data.organID})
                OPTIONAL MATCH
                    (description:Description {pbotID: $data.descriptionID})
                OPTIONAL MATCH
                    (otu:Description {pbotID: $data.otuID})
                CREATE 
                    (organ)<-[:IS_TYPE]-(specimen)
                WITH specimen, description, otu
                    CALL apoc.do.when(
                        description IS NOT NULL,
                        "CREATE (description)<-[:DESCRIBED_BY]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {description: description, specimen: specimen}) YIELD value
                WITH value.specimen AS specimen, otu
                    CALL apoc.do.when(
                        otu IS NOT NULL,
                        "CREATE (otu)<-[:EXAMPLE_OF]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {otu: otu, specimen: specimen}) YIELD value
                RETURN value.specimen as specimen           
            """
        )
        
    CustomDeleteSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
                MATCH 
                    (specimen:Specimen {pbotID: $data.pbotID})-[:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                WITH specimen, specimen.pbotID AS sID
                    DETACH DELETE specimen
                WITH {
                    pbotID: sID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateOrgan(data: OrganInput!): Organ!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (organ:Organ {
                        pbotID: apoc.create.uuid(),
                        type: $data.type
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                RETURN organ
            """
        )
        
    CustomUpdateOrgan(data: OrganInput!): Organ!
        @cypher(
            statement: """
                MATCH 
                    (organ:Organ {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
				CREATE
					(organ)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH organ, eb
                    CALL apoc.do.case([
                        organ.type IS NULL AND $data.type IS NOT NULL,
                        "SET eb.type = 'not present' RETURN eb",
                        organ.type IS NOT NULL AND ($data.type IS NULL OR organ.type <> $data.type), 
                        "SET eb.type = organ.type RETURN eb"],
                        "RETURN eb",
                        {organ: organ, eb:eb}
                    ) 
                    YIELD value
				WITH organ
                SET 
                    organ.type = $data.type
                RETURN organ
            """
        )
    CustomDeleteOrgan(data: OrganInput!): Organ!
        @cypher(
            statement: """
                MATCH 
                    (organ:Organ {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                WITH enteredBy, organ
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, organ, organ.pbotID AS oID
                    DELETE organ
                WITH {
                    pbotID: oID + " deleted"
                } AS result
                RETURN result
            """
        )

}
