scalar DateTime

""" These unions are a way for a property to hold references to different types """
union Enterable = Group | Person | Reference | Schema | Character | State | Description | CharacterInstance | Specimen

union Groupable = Reference | Schema | Character | State | Description | CharacterInstance | Specimen

union Authorable = Reference | Schema

union Statable = Character | State

type Group {
    pbotID: ID!
    name: String
    members: [Person!]! @relation(name: "MEMBER_OF", direction: IN)
    items: [Groupable!]! @relation(name: "ITEM_OF", direction: IN)
    enteredBy: [GroupEnteredBy]
}

""" Note that I had to use the cypher directive to populate the entered property.
    Ideally, this would be handled by a relation directive, but that does not appear to
    work with unions. """
type Person {
    pbotID: ID!
    given: String
    surname: String
    email: String
    orcid: String
    entered:   [Enterable] @cypher(
      statement: "match (n)-[:ENTERED_BY]->(this) return n"
    )
    authored: [Authorable!]! @relation(name: "AUTHORED_BY", direction: IN)
    enteredBy: [PersonEnteredBy]
}

type Reference {
    pbotID: ID!
    title: String
    year: String
    publisher: String
    doi: String
    citedBy: [Schema!]! @relation(name: "CITED_BY", direction: OUT)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    enteredBy: [ReferenceEnteredBy]
}

type Schema {
    pbotID: ID!
    title: String
    year: String
    cites: [Reference!]! @relation(name: "CITED_BY", direction: IN)
    characters: [Character] @relation(name: "CHARACTER_OF", direction: IN)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    appliedBy: [Description]! @relation(name: "APPLICATION_OF", direction: IN)
    enteredBy: [SchemaEnteredBy]
}

type Character {
    pbotID: ID!
    name: String
    definition: String
    characterOfSchema: Schema! @relation(name: "CHARACTER_OF", direction: OUT)
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [CharacterInstance!]! @relation(name: "INSTANCE_OF" direction: IN)
    enteredBy: [CharacterEnteredBy]
}

type State {
    pbotID: ID!
    name: String
    definition: String
    stateOf:  Statable! @cypher(
      statement: "match (this)-[:STATE_OF]->(n) return n limit 1"
    )
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [HasState]
    enteredBy: [StateEnteredBy]
}

""" Description Complex types """
type Organ {
    pbotID: ID!
    type: String
    specimens: [Specimen!]! @relation(name: "IS_TYPE" direction: IN)
    enteredBy: [OrganEnteredBy]
}

"""Note: schema should be non null, but isn't right now due to missing data"""
type Description {
    pbotID: ID!
    type: String
	name: String
	family: String
	genus: String
	species: String
    characterInstances: [CharacterInstance!]! @relation(name: "DEFINED_BY", direction: OUT)
    candidateCharacterInstances: [CharacterInstance!]! @relation(name: "CANDIDATE_FOR", direction: IN)
    exampleSpecimens: [ExampleOf!]!
    specimen: DescribedBy
    schema: Schema @relation(name: "APPLICATION_OF", direction: OUT)
    enteredBy: [DescriptionEnteredBy]
}

type CharacterInstance {
    pbotID: ID!
    character: Character @relation(name: "INSTANCE_OF", direction: OUT)
    state: HasState
    candidateForArchtype: Description @relation(name: "CANDIDATE_FOR", direction: OUT)
    description: Description @relation(name: "DEFINED_BY" direction: IN)
    enteredBy: [CharacterInstanceEnteredBy]
}

type Specimen {
    pbotID: ID!
    name: String
    locality: String
    organ: Organ @relation(name: "IS_TYPE", direction: OUT)
    description: DescribedBy
    archtypeDescription: ExampleOf
    enteredBy: [SpecimenEnteredBy]
}

""" In order to access relationship properties, the relationship must be specified with a standalone type.
    Ideally, there would be one of these for the ENTERED_BY relationship, with the Enterable union in the
    from property. That does not work. So, I've had to resort to creating a separate type for each node type
    that could be in the from property. I'm not sure of the cons here. It looks like crap though. """
type GroupEnteredBy @relation(name: "ENTERED_BY") {
  from: Group
  to: Person
  timestamp: DateTime
}

type PersonEnteredBy @relation(name: "ENTERED_BY") {
  from: Person
  to: Person
  timestamp: DateTime
}

type ReferenceEnteredBy @relation(name: "ENTERED_BY") {
  from: Reference
  to: Person
  timestamp: DateTime
}

type SchemaEnteredBy @relation(name: "ENTERED_BY") {
  from: Schema
  to: Person
  timestamp: DateTime
}

type CharacterEnteredBy @relation(name: "ENTERED_BY") {
  from: Character
  to: Person
  timestamp: DateTime
}

type StateEnteredBy @relation(name: "ENTERED_BY") {
  from: State
  to: Person
  timestamp: DateTime
}

type OrganEnteredBy @relation(name: "ENTERED_BY") {
  from: Organ
  to: Person
  timestamp: DateTime
}

type DescriptionEnteredBy @relation(name: "ENTERED_BY") {
  from: Description
  to: Person
  timestamp: DateTime
}

type CharacterInstanceEnteredBy @relation(name: "ENTERED_BY") {
  from: CharacterInstance
  to: Person
  timestamp: DateTime
}

type SpecimenEnteredBy @relation(name: "ENTERED_BY") {
  from: Specimen
  to: Person
  timestamp: DateTime
}


""" HAS_STATE for access to value """
type HasState @relation(name: "HAS_STATE") {
    from: CharacterInstance
    to: State
    value: String
}


""" EXAMPLE_OF for access to entered_by and timestamp """
type ExampleOf @relation(name: "EXAMPLE_OF") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}

""" DESCRIBED_BY for access to entered_by and timestamp """
type DescribedBy @relation(name: "DESCRIBED_BY") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}



"""
Not sure this will be useful, but it's a way to get at the leaf states in state hierarchies."""
type Query {
    GetLeafStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                where  
                    not (n)<-[:STATE_OF]-(:State) 
                return n            
            """
        )

    GetAllStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                return n            
            """
        )
}


""" //////////////////////////////////////////////////////////////////////////////////////////////////////
Mutations overrides. We might want to think about only using these, rather than any generated mutations. 
    TODO: To make these true overrides, delete the 'Custom' prefix. """

input GroupInput {
    pbotID: String
    name: String
    members: [String]
    items: [String]
    enteredByPersonID: String
}

input PersonInput {
    pbotID: String
    given: String
	surname: String
	email: String
	orcid: String
	enteredByPersonID: String
} 

input ReferenceInput {
    pbotID: String
    title: String
	year: String
	publisher: String
	doi: String
	authors: [String]
	enteredByPersonID: String
} 

input SchemaInput {
    pbotID: String
    title: String
	year: String
	references: [String]
	authors: [String]
	enteredByPersonID: String
	cascade: Boolean
}

input CharacterInput {
    pbotID: String
    name: String
    definition: String
    schemaID: String
	enteredByPersonID: String
	cascade: Boolean
}

input StateInput {
    pbotID: String
    name: String
    definition: String
    characterID: String
    parentStateID: String
    parentID: String
	enteredByPersonID: String
	cascade: Boolean
}

input DescriptionInput {
    pbotID: String
    type: String!
    specimenID: String
	name: String!
	family: String
	genus: String
	species: String
	schemaID: String!
	enteredByPersonID: String
	cascade: Boolean
}

input CharacterInstanceInput {
    pbotID: String
    descriptionID: String!
    characterID: String!
    stateID: String!
    quantity: String
	enteredByPersonID: String
}

input SpecimenInput {
    pbotID: String
    name: String!
    locality: String
    preservationMode: String
    idigbiouuid: String
    pbdbcid: String
    pbdboccid: String
    descriptionID: String
    otuID: String
    organID: String
	enteredByPersonID: String
}

input OrganInput {
    pbotID: String
    type: String!
	enteredByPersonID: String
}

type Mutation {
    CreateGroup(data: GroupInput!): Group! @neo4j_ignore
        @cypher(
            statement: """
                MATCH 
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (group: Group {
                        pbotID: apoc.create.uuid(),
                        name: $data.name
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(ePerson)
                WITH group
                UNWIND (CASE coalesce($data.members,0) WHEN 0 THEN [null] ELSE $data.members END) AS mID
                    CALL
                        apoc.do.when(
                            mID IS NULL,
                            "RETURN group",
                            "MATCH (n) WHERE n.pbotID = mID CREATE (n)-[:MEMBER_OF]->(group) RETURN group",
                            {mID:mID, group:group}
                        ) YIELD value
                WITH distinct group
                UNWIND (CASE coalesce($data.items,0) WHEN 0 THEN [null] ELSE $data.items END) AS iID
                    CALL
                        apoc.do.when(
                            iID IS NULL,
                            "RETURN group",
                            "MATCH (n) WHERE n.pbotID = iID CREATE (n)-[:ITEM_OF]->(group) RETURN group",
                            {iID:iID, group:group}
                        ) YIELD value
                WITH distinct group
                RETURN group
            """
        )
    UpdateGroup(data: GroupInput!): Group!  @neo4j_ignore
    DeleteGroup(data: GroupInput!): Group! @neo4j_ignore

        
    CreatePerson(data: PersonInput!): Person! @neo4j_ignore
        @cypher(
            statement: """
                MATCH 
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (person: Person {
                        pbotID: apoc.create.uuid(),
                        given: $data.given,
                        surname: $data.surname,
                        email: $data.email,
                        orcid: $data.orcid
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(ePerson)
                RETURN person
            """
        )
    UpdatePerson(data: PersonInput!): Person! @neo4j_ignore
    DeletePerson(data: PersonInput!): Person! @neo4j_ignore

    CreateReference(data: ReferenceInput!): Reference! @neo4j_ignore
    @cypher(
        statement: """
            MATCH 
                (person:Person {pbotID: $data.enteredByPersonID})
            CREATE 
                (reference: Reference {
                    pbotID: apoc.create.uuid(),
                    title: $data.title,
                    year: $data.year,
                    publisher: $data.publisher,
                    doi: $data.doi
                })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
            WITH reference
            UNWIND $data.authors AS aID
                MATCH (author:Person {pbotID: aID}) 
                CREATE (reference)-[:AUTHORED_BY]->(author)
            RETURN reference
        """
    )
    UpdateReference(data: ReferenceInput!): Reference! @neo4j_ignore
    DeleteReference(data: ReferenceInput!): Reference! @neo4j_ignore

    CreateSchema(data: SchemaInput!): Schema! @neo4j_ignore
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (schema:Schema {
                        pbotID: apoc.create.uuid(),
                        title: $data.title,
                        year: $data.year
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH schema
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (schema)-[:AUTHORED_BY]->(author)
                WITH collect(aID) as dummy, schema
                UNWIND $data.references as rID
                    MATCH (reference:Reference {pbotID: rID})
                    CREATE (reference)-[:CITED_BY]->(schema)
                WITH collect(rID)as dummy, schema
                RETURN schema
            """
        )
    UpdateSchema(data: SchemaInput!): Schema! @neo4j_ignore
    DeleteSchema(data: SchemaInput!): Schema! @neo4j_ignore
    
    CreateCharacter(data: CharacterInput!): Character! @neo4j_ignore
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (schema)<-[:CHARACTER_OF]-(character:Character {
                        pbotID: apoc.create.uuid(),
                        name: $data.name,
                        definition: $data.definition
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                RETURN character
            """
        )
    UpdateCharacter(data: CharacterInput!): Character! @neo4j_ignore
    DeleteCharacter(data: CharacterInput!): Character! @neo4j_ignore

    CreateState(data: StateInput!): State! @neo4j_ignore
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID}),
                    (parent) WHERE parent.pbotID = $data.parentID
                WITH parent, person
                    CREATE 
                        (parent)<-[:STATE_OF]-(state:State {
                            pbotID: apoc.create.uuid(),
                            name: $data.name,
                            definition:$data.definition
                        })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                    RETURN state           
            """
        )
    UpdateState(data: StateInput!): State! @neo4j_ignore
    DeleteState(data: StateInput!): State! @neo4j_ignore

    CreateDescription(data: DescriptionInput!): Description! @neo4j_ignore
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
                    (specimen:Specimen {pbotID: $data.specimenID})
                CREATE 
                    (schema)<-[:APPLICATION_OF]-(description: Description {
                        pbotID: apoc.create.uuid(),
                        type: $data.type,
                        name: $data.name,
                        family: $data.family,
                        genus: $data.genus,
                        species: $data.species
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH description, specimen
                CALL apoc.do.when(
                    specimen is not null, 
                    "CREATE (specimen)-[:DESCRIBED_BY]->(description) RETURN description", 
                    'RETURN description',
                    {specimen: specimen, description: description}
                ) YIELD value
                RETURN value.description AS description                
            """
        )
    UpdateDescription(data: DescriptionInput!): Description! @neo4j_ignore
    DeleteDescription(data: DescriptionInput!): Description!  @neo4j_ignore

    """NOTE: No when is needed for the HAS_STATE value property below since setting properties to null 
    means they don't exist."""
    CreateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (description:Description {pbotID: $data.descriptionID}),
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (description)-[:DEFINED_BY]->(characterInstance:CharacterInstance {
                        pbotID: apoc.create.uuid()
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person),
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity}]-(characterInstance) 
                RETURN characterInstance
            """
        )
    UpdateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance! @neo4j_ignore
    DeleteCharacterInstance(data: CharacterInstanceInput!): CharacterInstance! @neo4j_ignore

    CreateSpecimen(data: SpecimenInput!): Specimen! @neo4j_ignore
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID}),
                    (organ:Organ {pbotID: $data.organID})
                OPTIONAL MATCH
                    (description:Description {pbotID: $data.descriptionID})
                OPTIONAL MATCH
                    (otu:Description {pbotID: $data.otuID})
                CREATE
                    (organ)<-[:IS_TYPE]-(specimen:Specimen {
                        pbotID: apoc.create.uuid(),
                        name: $data.name,
                        locality: $data.locality,
                        preservationMode: $data.preservationMode,
                        idigbiouuid: $data.idigbiouuid,
                        pbdbcid: $data.pbdbcid,
                        pbdboccid: $data.pbdboccid
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH specimen, description, otu
                    CALL apoc.do.when(
                        description IS NOT NULL,
                        "CREATE (description)<-[:DESCRIBED_BY]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {description: description, specimen: specimen}) YIELD value
                    WITH value.specimen AS specimen, otu
                    CALL apoc.do.when(
                        otu IS NOT NULL,
                        "CREATE (otu)<-[:EXAMPLE_OF]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {otu: otu, specimen: specimen}) YIELD value
                RETURN value.specimen as specimen           
            """
        )
    UpdateSpecimen(data: SpecimenInput!): Specimen! @neo4j_ignore
    DeleteSpecimen(data: SpecimenInput!): Specimen! @neo4j_ignore

    CreateOrgan(data: OrganInput!): Organ! @neo4j_ignore
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (organ:Organ {
                        pbotID: apoc.create.uuid(),
                        type: $data.type
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                RETURN organ
            """
        )
    UpdateOrgan(data: OrganInput!): Organ! @neo4j_ignore
    DeleteOrgan(data: OrganInput!): Organ! @neo4j_ignore

}
