scalar DateTime

""" These unions are a way for a property to hold references to different types """
union Enterable = Person | Reference | Schema | Character | State

union Authorable = Reference | Schema

union Statable = Character | State

""" Note that I had to use the cypher directive to populate the entered property.
    Ideally, this would be handled by a relation directive, but that does not appear to
    work with unions. """
type Person {
    pbotID: ID!
    given: String
    surname: String
    email: String
    orcid: String
    entered:   [Enterable] @cypher(
      statement: "match (n)-[:ENTERED_BY]->(this) return n"
    )
    authored: [Authorable!]! @relation(name: "AUTHORED_BY", direction: IN)
}

type Reference {
    pbotID: ID!
    title: String
    year: String
    publisher: String
    doi: String
    citedBy: [Schema!]! @relation(name: "CITED_BY", direction: OUT)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    enteredBy: [ReferenceEnteredBy]
}

type Schema {
    pbotID: ID!
    title: String
    year: String
    cites: [Reference!]! @relation(name: "CITED_BY", direction: IN)
    characters: [Character] @relation(name: "CHARACTER_OF", direction: IN)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    appliedBy: [Description]! @relation(name: "APPLICATION_OF", direction: IN)
    enteredBy: [SchemaEnteredBy]
}

type Character {
    pbotID: ID!
    name: String
    definition: String
    characterOfSchema: Schema! @relation(name: "CHARACTER_OF", direction: OUT)
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [CharacterInstance!]! @relation(name: "INSTANCE_OF" direction: IN)
    enteredBy: [CharacterEnteredBy]
}

type State {
    pbotID: ID!
    name: String
    definition: String
    stateOf:  Statable! @cypher(
      statement: "match (this)-[:STATE_OF]->(n) return n limit 1"
    )
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [HasState]
    enteredBy: [StateEnteredBy]
}

""" Description Complex types """
type Organ {
    pbotID: ID!
    type: String
    specimens: [Specimen!]! @relation(name: "IS_TYPE" direction: IN)
    enteredBy: [OrganEnteredBy]
}

"""Note: schema should be non null, but isn't right now due to missing data"""
type Description {
    pbotID: ID!
    type: String
	name: String
	family: String
	genus: String
	species: String
    characterInstances: [CharacterInstance!]! @relation(name: "DEFINED_BY", direction: OUT)
    candidateCharacterInstances: [CharacterInstance!]! @relation(name: "CANDIDATE_FOR", direction: IN)
    exampleSpecimens: [ExampleOf!]!
    specimen: DescribedBy
    schema: Schema @relation(name: "APPLICATION_OF", direction: OUT)
    enteredBy: [DescriptionEnteredBy]
}

type CharacterInstance {
    pbotID: ID!
    character: Character @relation(name: "INSTANCE_OF", direction: OUT)
    state: HasState
    candidateForArchtype: Description @relation(name: "CANDIDATE_FOR", direction: OUT)
    description: Description @relation(name: "DEFINED_BY" direction: IN)
    enteredBy: [CharacterInstanceEnteredBy]
}

type Specimen {
    pbotID: ID!
    name: String
    locality: String
    organ: Organ @relation(name: "IS_TYPE", direction: OUT)
    description: DescribedBy
    archtypeDescription: ExampleOf
    enteredBy: [SpecimenEnteredBy]
}

""" In order to access relationship properties, the relationship must be specified with a standalone type.
    Ideally, there would be one of these for the ENTERED_BY relationship, with the Enterable union in the
    from property. That does not work. So, I've had to resort to creating a separate type for each node type
    that could be in the from property. I'm not sure of the cons here. It looks like crap though. """
type ReferenceEnteredBy @relation(name: "ENTERED_BY") {
  from: Reference
  to: Person
  timestamp: DateTime
}

type SchemaEnteredBy @relation(name: "ENTERED_BY") {
  from: Schema
  to: Person
  timestamp: DateTime
}

type CharacterEnteredBy @relation(name: "ENTERED_BY") {
  from: Character
  to: Person
  timestamp: DateTime
}

type StateEnteredBy @relation(name: "ENTERED_BY") {
  from: State
  to: Person
  timestamp: DateTime
}

type OrganEnteredBy @relation(name: "ENTERED_BY") {
  from: Organ
  to: Person
  timestamp: DateTime
}

type DescriptionEnteredBy @relation(name: "ENTERED_BY") {
  from: Description
  to: Person
  timestamp: DateTime
}

type CharacterInstanceEnteredBy @relation(name: "ENTERED_BY") {
  from: CharacterInstance
  to: Person
  timestamp: DateTime
}

type SpecimenEnteredBy @relation(name: "ENTERED_BY") {
  from: Specimen
  to: Person
  timestamp: DateTime
}


""" HAS_STATE for access to value """
type HasState @relation(name: "HAS_STATE") {
    from: CharacterInstance
    to: State
    value: String
}


""" EXAMPLE_OF for access to entered_by and timestamp """
type ExampleOf @relation(name: "EXAMPLE_OF") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}

""" DESCRIBED_BY for access to entered_by and timestamp """
type DescribedBy @relation(name: "DESCRIBED_BY") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}



"""
Not sure this will be useful, but it's a way to get at the leaf states in state hierarchies."""
type Query {
    GetLeafStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                where  
                    not (n)<-[:STATE_OF]-(:State) 
                return n            
            """
        )

    GetAllStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                return n            
            """
        )
}


""" //////////////////////////////////////////////////////////////////////////////////////////////////////
Mutations overrides. We might want to think about only using these, rather than any generated mutations. 
    TODO: To make these true overrides, delete the 'Custom' prefix. """

input PersonInput {
    pbotID: String
    given: String
	surname: String
	email: String
	orcid: String
	enteredByPersonID: String
} 

input ReferenceInput {
    pbotID: String
    title: String
	year: String
	publisher: String
	doi: String
	authors: [String]
	enteredByPersonID: String
} 

input SchemaInput {
    pbotID: String
    title: String
	year: String
	references: [String]
	authors: [String]
	enteredByPersonID: String
}

input CharacterInput {
    pbotID: String
    name: String
    definition: String
    schemaID: String
	enteredByPersonID: String
}

input StateInput {
    pbotID: String
    name: String
    definition: String
    characterID: String
    parentStateID: String
	enteredByPersonID: String
}

input DescriptionInput {
    pbotID: String
    type: String!
    specimenID: String
	name: String!
	family: String
	genus: String
	species: String
	schemaID: String!
	enteredByPersonID: String
}

input CharacterInstanceInput {
    pbotID: String
    descriptionID: String!
    characterID: String!
    stateID: String!
    quantity: String
	enteredByPersonID: String
}

input SpecimenInput {
    pbotID: String
    name: String!
    locality: String
    preservationMode: String
    idigbiouuid: String
    pbdbcid: String
    pbdboccid: String
    descriptionID: String
    otuID: String
    organID: String
	enteredByPersonID: String
}

input OrganInput {
    pbotID: String
    type: String!
	enteredByPersonID: String
}

type Mutation {
    CustomCreatePerson(data: PersonInput!): Person!
        @cypher(
            statement: """
                MATCH 
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (person: Person {
                        pbotID: apoc.create.uuid(),
                        given: $data.given,
                        surname: $data.surname,
                        email: $data.email,
                        orcid: $data.orcid
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(ePerson)
                RETURN person
            """
        )

    CustomUpdatePerson(data: PersonInput!): Person!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                CREATE
                    (person)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH person, eb
                    CALL apoc.do.when(
                        person.given <> $data.given, 
                        "SET eb.given = person.given RETURN eb",
                        "RETURN eb",
                        {person: person, eb:eb}
                    ) YIELD value
                WITH person, value.eb AS eb
                    CALL apoc.do.when(
                        person.surname <> $data.surname, 
                        "SET eb.surname = person.surname RETURN eb",
                        "RETURN eb",
                        {person: person, eb:eb}
                    ) YIELD value
                WITH person, value.eb AS eb
                    CALL apoc.do.when(
                        person.email <> $data.email, 
                        "SET eb.email = person.email RETURN eb",
                        "RETURN eb",
                        {person: person, eb:eb}
                    ) YIELD value
                WITH person, value.eb AS eb
                    CALL apoc.do.when(
                        person.orcid <> $data.orcid, 
                        "SET eb.orcid = person.orcid RETURN eb",
                        "RETURN eb",
                        {person: person, eb:eb}
                    ) YIELD value
                WITH person
                SET 
                    person.given = $data.given,
                    person.surname = $data.surname,
                    person.email = $data.email,
                    person.orcid = $data.orcid
                RETURN person
            """
        )

    CustomDeletePerson(data: PersonInput!): Person!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                WITH enteredBy, person
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, person, person.pbotID AS pID
                    DELETE person
                WITH {
                    pbotID: pID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateReference(data: ReferenceInput!): Reference!
    @cypher(
        statement: """
            MATCH 
                (person:Person {pbotID: $data.enteredByPersonID})
            CREATE 
                (reference: Reference {
                    pbotID: apoc.create.uuid(),
                    title: $data.title,
                    year: $data.year,
                    publisher: $data.publisher,
                    doi: $data.doi
                })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
            WITH reference
            UNWIND $data.authors AS aID
                MATCH (author:Person {pbotID: aID}) 
                CREATE (reference)-[:AUTHORED_BY]->(author)
            RETURN reference
        """
    )

    CustomUpdateReference(data: ReferenceInput!): Reference!
        @cypher(
            statement: """
                MATCH 
					(reference:Reference {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                WITH reference, ePerson					
				CREATE
					(reference)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH reference, eb
                    CALL apoc.do.when(
                        reference.title IS NOT NULL AND reference.title <> $data.title, 
                        "SET eb.title = reference.title RETURN eb",
                        "RETURN eb",
                        {reference: reference, eb:eb}
                    ) YIELD value
                WITH reference, value.eb AS eb
                    CALL apoc.do.when(
                        reference.year IS NOT NULL AND reference.year <> $data.year, 
                        "SET eb.year = reference.year RETURN eb",
                        "RETURN eb",
                        {reference: reference, eb:eb}
                    ) YIELD value
                WITH reference, value.eb AS eb
                    CALL apoc.do.when(
                        reference.publisher IS NOT NULL AND reference.publisher <> $data.publisher, 
                        "SET eb.publisher = reference.publisher RETURN eb",
                        "RETURN eb",
                        {reference: reference, eb:eb}
                    ) YIELD value
                WITH reference, value.eb AS eb
                    CALL apoc.do.when(
                        reference.doi IS NOT NULL AND reference.doi <> $data.doi, 
                        "SET eb.doi = reference.doi RETURN eb",
                        "RETURN eb",
                        {reference: reference, eb:eb}
                    ) YIELD value
                WITH reference, value.eb AS eb
                OPTIONAL MATCH
					(person:Person)<-[oldAuthorRelationship:AUTHORED_BY]-(reference)
                WITH 
                    collect(person.pbotID) as oldAuthors, collect(oldAuthorRelationship) AS oars, reference, eb
                UNWIND oars AS ar
                    DELETE ar
                WITH collect(ar) as dummy, oldAuthors, reference, apoc.coll.disjunction(oldAuthors, $data.authors ) AS diffList, eb
                CALL
                    apoc.do.when(
                        SIZE(diffList)<>0,
                        "SET eb.authors = oldAuthors RETURN eb",
                        "RETURN eb",
                        {diffList: diffList, oldAuthors: oldAuthors, eb: eb}
                    )
                YIELD value
                WITH reference
                SET 
                    reference.title = $data.title,
                    reference.year = $data.year,
                    reference.publisher = $data.publisher,
                    reference.doi = $data.doi
                WITH reference
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (reference)-[:AUTHORED_BY]->(author)
                WITH collect(aID) as dummy, reference
                RETURN reference
            """
        )
        
    CustomDeleteReference(data: ReferenceInput!): Reference!
        @cypher(
            statement: """
                MATCH 
                    (reference:Reference {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                OPTIONAL MATCH
					(:Person)<-[oldAuthorRelationship:AUTHORED_BY]-(reference)
                WITH enteredBy, oldAuthorRelationship, reference
                UNWIND oldAuthorRelationship AS oAR 
                    DELETE oAR
                WITH collect(oAR) AS dummy, enteredBy, reference
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, reference, reference.pbotID AS rID
                    DELETE reference
                WITH {
                    pbotID: rID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateSchema(data: SchemaInput!): Schema!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (schema:Schema {
                        pbotID: apoc.create.uuid(),
                        title: $data.title,
                        year: $data.year
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH schema
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (schema)-[:AUTHORED_BY]->(author)
                WITH collect(aID) as dummy, schema
                UNWIND $data.references as rID
                    MATCH (reference:Reference {pbotID: rID})
                    CREATE (reference)-[:CITED_BY]->(schema)
                WITH collect(rID)as dummy, schema
                RETURN schema
            """
        )

    CustomUpdateSchema(data: SchemaInput!): Schema!
        @cypher(
            statement: """
                MATCH 
					(schema:Schema {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
				WITH schema, ePerson
				CREATE
					(schema)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH schema, eb
                    CALL apoc.do.when(
                        schema.title IS NOT NULL AND schema.title <> $data.title, 
                        "SET eb.title = schema.title RETURN eb",
                        "RETURN eb",
                        {schema: schema, eb:eb}
                    ) YIELD value
                WITH schema, value.eb AS eb
                    CALL apoc.do.when(
                        schema.year IS NOT NULL AND schema.year <> $data.year, 
                        "SET eb.year = schema.year RETURN eb",
                        "RETURN eb",
                        {schema: schema, eb:eb}
                    ) YIELD value
                OPTIONAL MATCH
					(reference:Reference)-[oldCitationRelationship:CITED_BY]->(schema)
                WITH schema, eb, collect(reference.pbotID) AS oldRefs, collect(oldCitationRelationship) AS ocrs
                UNWIND ocrs AS cr
                    DELETE cr
                WITH collect(cr) as dummy, schema, oldRefs, apoc.coll.disjunction(oldRefs, $data.references ) AS diffList, eb
                CALL
                    apoc.do.when(
                        SIZE(diffList)<>0,
                        "SET eb.references = oldRefs RETURN eb",
                        "RETURN eb",
                        {diffList: diffList, oldRefs: oldRefs, eb: eb}
                    )
                YIELD value
				WITH schema, eb
                OPTIONAL MATCH
					(person:Person)<-[oldAuthorRelationship:AUTHORED_BY]-(schema)
                WITH schema, eb, collect(person.pbotID) as oldAuthors, collect(oldAuthorRelationship) AS oars
                UNWIND oars AS ar
                    DELETE ar
                WITH collect(ar) as dummy, schema, oldAuthors, apoc.coll.disjunction(oldAuthors, $data.authors ) AS diffList, eb
                CALL
                    apoc.do.when(
                        SIZE(diffList)<>0,
                        "SET eb.authors = oldAuthors RETURN eb",
                        "RETURN eb",
                        {diffList: diffList, oldAuthors: oldAuthors, eb: eb}
                    )
                YIELD value
				WITH schema
                SET 
                    schema.title = $data.title,
                    schema.year = $data.year
                WITH schema
                UNWIND $data.references AS rID
                    MATCH (reference:Reference {pbotID: rID}) 
                    CREATE (reference)-[:CITED_BY]->(schema)
                WITH collect(rID) AS dummy, schema
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (schema)-[:AUTHORED_BY]->(author)
                WITH collect (aID) as dummy, schema
                RETURN schema
            """
        )
        
    CustomDeleteSchema(data: SchemaInput!): Schema!
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                OPTIONAL MATCH
					(:Person)<-[oldAuthorRelationship:AUTHORED_BY]-(schema)
                OPTIONAL MATCH
					(:Reference)-[oldCitationRelationship:CITED_BY]->(schema)
                WITH enteredBy, oldAuthorRelationship, oldCitationRelationship, schema
                UNWIND oldAuthorRelationship AS oAR 
                    DELETE oAR
                WITH collect(oAR) AS dummy, enteredBy, oldCitationRelationship, schema
                UNWIND oldCitationRelationship AS oCR 
                    DELETE oCR
                WITH collect(oCR) AS dummy, enteredBy, schema
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, schema, schema.pbotID AS sID
                    DELETE schema
                WITH {
                    pbotID: sID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateCharacter(data: CharacterInput!): Character!
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (schema)<-[:CHARACTER_OF]-(character:Character {
                        pbotID: apoc.create.uuid(),
                        name: $data.name,
                        definition: $data.definition
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                RETURN character
            """
        )

    CustomUpdateCharacter(data: CharacterInput!): Character!
        @cypher(
            statement: """
                MATCH 
					(character:Character {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                WITH character, ePerson					
				CREATE
					(character)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH character, eb
                    CALL apoc.do.when(
                        character.name IS NOT NULL AND character.name <> $data.name, 
                        "SET eb.name = character.name RETURN eb",
                        "RETURN eb",
                        {character: character, eb:eb}
                    ) YIELD value
                WITH character, value.eb AS eb
                    CALL apoc.do.when(
                        character.definition IS NOT NULL AND character.definition <> $data.definition, 
                        "SET eb.definition = character.definition RETURN eb",
                        "RETURN eb",
                        {character: character, eb:eb}
                    ) YIELD value
				WITH character
                SET 
                    character.name = $data.name,
                    character.definition = $data.definition
                RETURN character
            """
        )
        
    CustomDeleteCharacter(data: CharacterInput!): Character!
        @cypher(
            statement: """
                MATCH 
                    (character:Character {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                OPTIONAL MATCH
					(:Schema)<-[oldSchemaRelationship:CHARACTER_OF]-(character)
                WITH enteredBy, oldSchemaRelationship, character
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, oldSchemaRelationship, character, character.pbotID AS cID
                    DELETE oldSchemaRelationship
                    DELETE character
                WITH {
                    pbotID: cID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateState(data: StateInput!): State!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CALL apoc.case([
                    $data.parentStateID is null, "MATCH (parent:Character {pbotID: characterID}) RETURN parent",
                    $data.parentStateID is not null, "MATCH (parent:State {pbotID: parentStateID}) RETURN parent"],
                    'RETURN "" as parent',
                    {characterID: $data.characterID, parentStateID: $data.parentStateID}
                ) YIELD value 
                WITH value.parent as parent, person
                    CREATE 
                        (parent)<-[:STATE_OF]-(state:State {
                            pbotID: apoc.create.uuid(),
                            name: $data.name,
                            definition:$data.definition
                        })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                    RETURN state           
            """
        )

    CustomUpdateState(data: StateInput!): State!
        @cypher(
            statement: """
                MATCH 
					(state:State {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
				CREATE
					(state)-[eb:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(ePerson)
                WITH state, eb
                    CALL apoc.do.when(
                        state.name IS NOT NULL AND state.name <> $data.name, 
                        "SET eb.name = state.name RETURN eb",
                        "RETURN eb",
                        {state: state, eb:eb}
                    ) YIELD value
                WITH state, value.eb AS eb
                    CALL apoc.do.when(
                        state.definition IS NOT NULL AND state.definition <> $data.definition, 
                        "SET eb.definition = state.definition RETURN eb",
                        "RETURN eb",
                        {state: state, eb:eb}
                    ) YIELD value
				WITH state, eb
                OPTIONAL MATCH
					(oldParent)<-[oldParentRelationship:STATE_OF]-(state)
				DELETE oldParentRelationship
                WITH state, eb, oldParent.pbotID AS oldParent
                CALL apoc.case([
                    $data.parentStateID is null, "MATCH (parent:Character {pbotID: characterID}) RETURN parent",
                    $data.parentStateID is not null, "MATCH (parent:State {pbotID: parentStateID}) RETURN parent"],
                    'RETURN "" as parent',
                    {characterID: $data.characterID, parentStateID: $data.parentStateID}
                ) YIELD value 
                WITH value.parent as parent, state, oldParent, eb
                CALL
                    apoc.do.when(
                        oldParent <> parent.pbotID,
                        "SET eb.parent = oldParent RETURN eb",
                        "RETURN eb",
                        {oldParent: oldParent, eb: eb}
                    )
                YIELD value
				WITH state, parent
                SET 
                    state.name = $data.name,
                    state.definition = $data.definition
                CREATE
                    (state)-[:STATE_OF]->(parent)
                RETURN state           
            """
        )
        
    CustomDeleteState(data: StateInput!): State!
        @cypher(
            statement: """
                MATCH 
                    (state:State {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID}),
                    ()<-[oldParentRelationship:STATE_OF]-(state)
                WITH enteredBy, oldParentRelationship, state
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, oldParentRelationship, state, state.pbotID AS sID
                    DELETE oldParentRelationship
                    DELETE state
                WITH {
                    pbotID: sID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
                    (specimen:Specimen {pbotID: $data.specimenID})
                CREATE 
                    (schema)<-[:APPLICATION_OF]-(description: Description {
                        pbotID: apoc.create.uuid(),
                        type: $data.type,
                        name: $data.name,
                        family: $data.family,
                        genus: $data.genus,
                        species: $data.species
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH description, specimen
                CALL apoc.do.when(
                    specimen is not null, 
                    "CREATE (specimen)-[:DESCRIBED_BY]->(description) RETURN description", 
                    'RETURN description',
                    {specimen: specimen, description: description}
                ) YIELD value
                RETURN value.description AS description                
            """
        )

    CustomUpdateDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
					(description:Description {pbotID: $data.pbotID}),
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
                    (specimen:Specimen {pbotID: $data.specimenID})
                OPTIONAL MATCH
					(:Schema)<-[oldSchemaRelationship:APPLICATION_OF]-(description)
                OPTIONAL MATCH
					(:Specimen)-[oldSpecimenRelationship:DESCRIBED_BY]->(description)
				SET
					description.type = $data.type,
					description.name = $data.name,
					description.family = $data.family,
					description.genus = $data.genus,
					description.species = $data.species
				DELETE oldSchemaRelationship 
                CREATE 
                    (schema)<-[:APPLICATION_OF]-(description)
				CREATE
					(description)-[:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(person)
                WITH description, specimen, oldSpecimenRelationship
                CALL apoc.do.when(
                    specimen is not null, 
                    'DELETE oldSpecimenRelationship CREATE (specimen)-[:DESCRIBED_BY]->(description) RETURN description', 
                    'RETURN description',
                    {specimen: specimen, description: description, oldSpecimenRelationship: oldSpecimenRelationship}
                ) YIELD value
                RETURN value.description AS description                
            """
        )
        
    """NOTE: For now, only allowing delete of nodes entered by same user. Will likely need further logic here.
    ALSO NOTE: Error reporting is not the best here. I had tried to use apoc.do.when to check for DEFINED_BY before deleting, but
    it seems that routine only accepts one relationship of a type at a time, so can't UNWIND within it. Instead, I'm just ignoring
    DEFINED_BY ad letting cypher catch the problem and rollback the operation. But this results in less than ideal error messaging to the client."""
    CustomDeleteDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
                    (description:Description {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(person:Person {pbotID:$data.enteredByPersonID})
                OPTIONAL MATCH
                    (description)-[applicationOf:APPLICATION_OF]->(:Schema)
                OPTIONAL MATCH
                    (description)<-[describedBy:DESCRIBED_BY]-(:Specimen)
                WITH enteredBy, applicationOf, describedBy, description
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, applicationOf, describedBy, description 
                    DELETE applicationOf, describedBy 
                WITH description, description.pbotID AS dID
                    DELETE description
                WITH {
                    pbotID: dID + " deleted"
                } AS result
                RETURN result
            """
        )

    """NOTE: No when is needed for the HAS_STATE value property below since setting properties to null 
    means they don't exist."""
    CustomCreateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (description:Description {pbotID: $data.descriptionID}),
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (description)-[:DEFINED_BY]->(characterInstance:CharacterInstance {
                        pbotID: apoc.create.uuid()
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person),
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity, type:"CREATE"}]-(characterInstance) 
                RETURN characterInstance
            """
        )

    CustomUpdateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (characterInstance:CharacterInstance {pbotID: $data.pbotID}),
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
					(:Character)<-[oldCharacterRelationship:INSTANCE_OF]-(characterInstance)
                OPTIONAL MATCH
					(:State)<-[oldStateRelationship:HAS_STATE]-(characterInstance)
                DELETE oldCharacterRelationship
                DELETE oldStateRelationship
                CREATE 
                    (characterInstance)-[:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(person),
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity}]-(characterInstance) 
                RETURN characterInstance
            """
        )

    CustomDeleteCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (characterInstance:CharacterInstance {pbotID: $data.pbotID})-[:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                WITH characterInstance, characterInstance.pbotID AS cIID
                    DETACH DELETE characterInstance
                WITH {
                    pbotID: cIID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID}),
                    (organ:Organ {pbotID: $data.organID})
                OPTIONAL MATCH
                    (description:Description {pbotID: $data.descriptionID})
                OPTIONAL MATCH
                    (otu:Description {pbotID: $data.otuID})
                CREATE
                    (organ)<-[:IS_TYPE]-(specimen:Specimen {
                        pbotID: apoc.create.uuid(),
                        name: $data.name,
                        locality: $data.locality,
                        preservationMode: $data.preservationMode,
                        idigbiouuid: $data.idigbiouuid,
                        pbdbcid: $data.pbdbcid,
                        pbdboccid: $data.pbdboccid
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                WITH specimen, description, otu
                    CALL apoc.do.when(
                        description IS NOT NULL,
                        "CREATE (description)<-[:DESCRIBED_BY]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {description: description, specimen: specimen}) YIELD value
                    WITH value.specimen AS specimen, otu
                    CALL apoc.do.when(
                        otu IS NOT NULL,
                        "CREATE (otu)<-[:EXAMPLE_OF]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {otu: otu, specimen: specimen}) YIELD value
                RETURN value.specimen as specimen           
            """
        )

    CustomUpdateSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
                MATCH 
					(specimen:Specimen {pbotID: $data.pbotID}),
                    (person:Person {pbotID: $data.enteredByPersonID}),
                    (organ:Organ {pbotID: $data.organID}),
					(specimen)-[oldOrganRelationship:IS_TYPE]->(:Organ)
                OPTIONAL MATCH
                    (description:Description {descriptionID: $data.descriptionID})
                OPTIONAL MATCH
                    (otu:Description {pbotID: $data.otuID})
                OPTIONAL MATCH
					(specimen)-[oldDescribedByRelationship:DESCRIBED_BY]->(:Description)
                OPTIONAL MATCH
					(specimen)-[oldExampleOfRelationship:EXAMPLE_OF]->(:Description)
				SET
                    specimen.name = $data.name,
                    specimen.locality = $data.locality,
                    specimen.preservationMode = $data.preservationMode,
                    specimen.idigbiouuid = $data.idigbiouuid,
                    specimen.pbdbcid = $data.pbdbcid,
                    specimen.pbdboccid = $data.pbdboccid
				DELETE oldOrganRelationship 
                CREATE 
                    (organ)<-[:IS_TYPE]-(specimen)
				CREATE
					(specimen)-[:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(person)
                WITH specimen, description, otu, oldDescribedByRelationship, oldExampleOfRelationship
                    CALL apoc.do.when(
                        description IS NOT NULL,
                        "DELETE oldDescribedByRelationship CREATE (description)<-[:DESCRIBED_BY]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {description: description, specimen: specimen, oldDescribedByRelationship: oldDescribedByRelationship}) YIELD value
                    WITH value.specimen AS specimen, otu, oldExampleOfRelationship
                    CALL apoc.do.when(
                        otu IS NOT NULL,
                        "DELETE oldExampleOfRelationship CREATE (otu)<-[:EXAMPLE_OF]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {otu: otu, specimen: specimen, oldExampleOfRelationship: oldExampleOfRelationship}) YIELD value
                RETURN value.specimen as specimen           
            """
        )
        
    CustomDeleteSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
                MATCH 
                    (specimen:Specimen {pbotID: $data.pbotID})-[:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                WITH specimen, specimen.pbotID AS sID
                    DETACH DELETE specimen
                WITH {
                    pbotID: sID + " deleted"
                } AS result
                RETURN result
            """
        )

    CustomCreateOrgan(data: OrganInput!): Organ!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (organ:Organ {
                        pbotID: apoc.create.uuid(),
                        type: $data.type
                    })-[:ENTERED_BY {timestamp: datetime(), type:"CREATE"}]->(person)
                RETURN organ
            """
        )
        
    CustomUpdateOrgan(data: OrganInput!): Organ!
        @cypher(
            statement: """
                MATCH 
                    (organ:Organ {pbotID: $data.pbotID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                SET 
                    organ.type = $data.type
                CREATE
                    (organ)-[:ENTERED_BY {timestamp: datetime(), type:"EDIT"}]->(person)
                RETURN organ
            """
        )
    CustomDeleteOrgan(data: OrganInput!): Organ!
        @cypher(
            statement: """
                MATCH 
                    (organ:Organ {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(:Person {pbotID:$data.enteredByPersonID})
                WITH enteredBy, organ
                UNWIND enteredBy AS eb 
                    DELETE eb
                WITH collect(eb) AS dummy, organ, organ.pbotID AS oID
                    DELETE organ
                WITH {
                    pbotID: oID + " deleted"
                } AS result
                RETURN result
            """
        )

}
