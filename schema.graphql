scalar DateTime

""" These unions are a way for a property to hold references to different types """
union Enterable = Person | Reference | Schema | Character | State

union Authorable = Reference | Schema

union Statable = Character | State

""" Note that I had to use the cypher directive to populate the entered property.
    Ideally, this would be handled by a relation directive, but that does not appear to
    work with unions. """
type Person {
    pbotID: ID!
    given: String
    surname: String
    email: String
    orcid: String
    entered:   [Enterable] @cypher(
      statement: "match (n)-[:ENTERED_BY]->(this) return n"
    )
    authored: [Authorable!]! @relation(name: "AUTHORED_BY", direction: IN)
}

type Reference {
    pbotID: ID!
    title: String
    year: String
    publisher: String
    doi: String
    citedBy: [Schema!]! @relation(name: "CITED_BY", direction: OUT)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    enteredBy: [ReferenceEnteredBy]
}

type Schema {
    pbotID: ID!
    title: String
    year: String
    cites: [Reference!]! @relation(name: "CITED_BY", direction: IN)
    characters: [Character] @relation(name: "CHARACTER_OF", direction: IN)
    authoredBy: [Person!]! @relation(name: "AUTHORED_BY", direction: OUT)
    appliedBy: [Description]! @relation(name: "APPLICATION_OF", direction: IN)
    enteredBy: [SchemaEnteredBy]
}

type Character {
    pbotID: ID!
    name: String
    definition: String
    characterOfSchema: Schema! @relation(name: "CHARACTER_OF", direction: OUT)
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [CharacterInstance!]! @relation(name: "INSTANCE_OF" direction: IN)
    enteredBy: [CharacterEnteredBy]
}

type State {
    pbotID: ID!
    name: String
    definition: String
    stateOf:  Statable! @cypher(
      statement: "match (this)-[:STATE_OF]->(n) return n limit 1"
    )
    states: [State!]! @relation(name: "STATE_OF", direction: IN)
    characterInstances: [HasState]
    enteredBy: [StateEnteredBy]
}

""" Description Complex types """
type Organ {
    pbotID: ID!
    type: String
    specimens: [Specimen!]! @relation(name: "IS_TYPE" direction: IN)
    enteredBy: [OrganEnteredBy]
}

"""Note: schema should be non null, but isn't right now due to missing data"""
type Description {
    pbotID: ID!
    type: String
	name: String
	family: String
	genus: String
	species: String
    characterInstances: [CharacterInstance!]! @relation(name: "DEFINED_BY", direction: OUT)
    candidateCharacterInstances: [CharacterInstance!]! @relation(name: "CANDIDATE_FOR", direction: IN)
    exampleSpecimens: [ExampleOf!]!
    specimen: DescribedBy
    schema: Schema @relation(name: "APPLICATION_OF", direction: OUT)
    enteredBy: [DescriptionEnteredBy]
}

type CharacterInstance {
    pbotID: ID!
    character: Character @relation(name: "INSTANCE_OF", direction: OUT)
    state: HasState
    candidateForArchtype: Description @relation(name: "CANDIDATE_FOR", direction: OUT)
    description: Description @relation(name: "DEFINED_BY" direction: IN)
    enteredBy: [CharacterInstanceEnteredBy]
}

type Specimen {
    pbotID: ID!
    name: String
    locality: String
    organ: Organ @relation(name: "IS_TYPE", direction: OUT)
    description: DescribedBy
    archtypeDescription: ExampleOf
    enteredBy: [SpecimenEnteredBy]
}

""" In order to access relationship properties, the relationship must be specified with a standalone type.
    Ideally, there would be one of these for the ENTERED_BY relationship, with the Enterable union in the
    from property. That does not work. So, I've had to resort to creating a separate type for each node type
    that could be in the from property. I'm not sure of the cons here. It looks like crap though. """
type ReferenceEnteredBy @relation(name: "ENTERED_BY") {
  from: Reference
  to: Person
  timestamp: DateTime
}

type SchemaEnteredBy @relation(name: "ENTERED_BY") {
  from: Schema
  to: Person
  timestamp: DateTime
}

type CharacterEnteredBy @relation(name: "ENTERED_BY") {
  from: Character
  to: Person
  timestamp: DateTime
}

type StateEnteredBy @relation(name: "ENTERED_BY") {
  from: State
  to: Person
  timestamp: DateTime
}

type OrganEnteredBy @relation(name: "ENTERED_BY") {
  from: Organ
  to: Person
  timestamp: DateTime
}

type DescriptionEnteredBy @relation(name: "ENTERED_BY") {
  from: Description
  to: Person
  timestamp: DateTime
}

type CharacterInstanceEnteredBy @relation(name: "ENTERED_BY") {
  from: CharacterInstance
  to: Person
  timestamp: DateTime
}

type SpecimenEnteredBy @relation(name: "ENTERED_BY") {
  from: Specimen
  to: Person
  timestamp: DateTime
}


""" HAS_STATE for access to value """
type HasState @relation(name: "HAS_STATE") {
    from: CharacterInstance
    to: State
    value: String
}


""" EXAMPLE_OF for access to entered_by and timestamp """
type ExampleOf @relation(name: "EXAMPLE_OF") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}

""" DESCRIBED_BY for access to entered_by and timestamp """
type DescribedBy @relation(name: "DESCRIBED_BY") {
    from: Specimen
    to: Description
    entered_by: ID!
    timestamp: DateTime
}



"""
Not sure this will be useful, but it's a way to get at the leaf states in state hierarchies."""
type Query {
    GetLeafStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                where  
                    not (n)<-[:STATE_OF]-(:State) 
                return n            
            """
        )

    GetAllStates(characterID: String!): [State]
        @cypher(
            statement: """
                match 
                    (:Character {pbotID: $characterID})<-[:STATE_OF*1..100]-(n:State) 
                return n            
            """
        )
}


""" //////////////////////////////////////////////////////////////////////////////////////////////////////
Mutations overrides. We might want to think about only using these, rather than any generated mutations. 
    TODO: To make these true overrides, delete the 'Custom' prefix. """

input PersonInput {
    pbotID: String
    given: String
	surname: String
	email: String
	orcid: String
	enteredByPersonID: String
} 

input ReferenceInput {
    pbotID: String
    title: String
	year: String
	publisher: String
	doi: String
	authors: [String]
	enteredByPersonID: String
} 

input SchemaInput {
    pbotID: String
    title: String
	year: String
	references: [String]
	authors: [String]
	enteredByPersonID: String
}

input CharacterInput {
    pbotID: String
    name: String
    definition: String
    schemaID: String
	enteredByPersonID: String
}

input StateInput {
    pbotID: String
    name: String
    definition: String
    characterID: String
    parentStateID: String
	enteredByPersonID: String
}

input DescriptionInput {
    pbotID: String
    type: String!
    specimenID: String
	name: String!
	family: String
	genus: String
	species: String
	schemaID: String!
	enteredByPersonID: String
}

input CharacterInstanceInput {
    pbotID: String
    descriptionID: String!
    characterID: String!
    stateID: String!
    quantity: String
	enteredByPersonID: String
}

input SpecimenInput {
    pbotID: String
    name: String!
    locality: String
    preservationMode: String
    idigbiouuid: String
    pbdbcid: String
    pbdboccid: String
    descriptionID: String
    otuID: String
    organID: String
	enteredByPersonID: String
}

input OrganInput {
    type: String!
	enteredByPersonID: String
}

type Mutation {
    CustomCreatePerson(data: PersonInput!): Person!
        @cypher(
            statement: """
                MATCH 
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (person: Person {
                        pbotID: apoc.create.uuid(),
                        given: $data.given,
                        surname: $data.surname,
                        email: $data.email,
                        orcid: $data.orcid
                    })-[:ENTERED_BY {timestamp: datetime()}]->(ePerson)
                RETURN person
            """
        )

    CustomUpdatePerson(data: PersonInput!): Person!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.pbotID}),
                    (ePerson:Person {pbotID: $data.enteredByPersonID})
                SET 
                    person.given = $data.given,
                    person.surname = $data.surname,
                    person.email = $data.email,
                    person.orcid = $data.orcid
                CREATE
                    (person)-[:ENTERED_BY {timestamp: datetime()}]->(ePerson)
                RETURN person
            """
        )

    CustomDeletePerson(data: PersonInput!): Person!
        @cypher(
            statement: """
				WITH {
					pbotID: "Not yet implemented"
				} AS result
                RETURN result                
            """
        )

        CustomCreateReference(data: ReferenceInput!): Reference!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (reference: Reference {
                        pbotID: apoc.create.uuid(),
                        title: $data.title,
                        year: $data.year,
                        publisher: $data.publisher,
                        doi: $data.doi
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person)
                WITH reference
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (reference)-[:AUTHORED_BY]->(author)
                RETURN reference
            """
        )

    CustomUpdateReference(data: ReferenceInput!): Reference!
        @cypher(
            statement: """
                MATCH 
					(reference:Reference {pbotID: $data.pbotID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
					(:Person)<-[oldAuthorRelationship:AUTHORED_BY]-(reference)
                WITH reference, person, collect(oldAuthorRelationship) AS oars
                SET 
                    reference.title = $data.title,
                    reference.year = $data.year,
                    reference.publisher = $data.publisher,
                    reference.doi = $data.doi
				CREATE
					(reference)-[:ENTERED_BY {timestamp: datetime()}]->(person)
                WITH reference, oars
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (reference)-[:AUTHORED_BY]->(author)
                WITH collect(aID) as dummy, reference, oars
                UNWIND oars AS ar
                    DELETE ar
                RETURN reference
            """
        )
        
    CustomDeleteReference(data: ReferenceInput!): Reference!
        @cypher(
            statement: """
				WITH {
					pbotID: "Not yet implemented"
				} AS result
                RETURN result                
            """
        )

    CustomCreateSchema(data: SchemaInput!): Schema!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (schema:Schema {
                        pbotID: apoc.create.uuid(),
                        title: $data.title,
                        year: $data.year
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person)
                WITH schema
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (schema)-[:AUTHORED_BY]->(author)
                WITH collect(aID) as dummy, schema
                UNWIND $data.references as rID
                    MATCH (reference:Reference {pbotID: rID})
                    CREATE (reference)-[:CITED_BY]->(schema)
                WITH collect(rID)as dummy, schema
                RETURN schema
            """
        )

    CustomUpdateSchema(data: SchemaInput!): Schema!
        @cypher(
            statement: """
                MATCH 
					(schema:Schema {pbotID: $data.pbotID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
					(:Reference)-[oldCitationRelationship:CITED_BY]->(schema)
                WITH schema, person, collect(oldCitationRelationship) AS ocrs
                OPTIONAL MATCH
					(:Person)<-[oldAuthorRelationship:AUTHORED_BY]-(schema)
                WITH schema, person, ocrs, collect(oldAuthorRelationship) AS oars
                SET 
                    schema.title = $data.title,
                    schema.year = $data.year
				CREATE
					(schema)-[:ENTERED_BY {timestamp: datetime()}]->(person)
                WITH schema, ocrs, oars
                UNWIND $data.references AS rID
                    MATCH (reference:Reference {pbotID: rID}) 
                    CREATE (reference)-[:CITED_BY]->(schema)
                WITH collect(rID) AS dummy, schema, ocrs, oars
                UNWIND ocrs AS cr
                    DELETE cr
                WITH collect(cr) AS dummy, schema, oars
                UNWIND $data.authors AS aID
                    MATCH (author:Person {pbotID: aID}) 
                    CREATE (schema)-[:AUTHORED_BY]->(author)
                WITH collect (aID) as dummy, schema, oars
                UNWIND oars AS ar
                    DELETE ar
                WITH schema
                RETURN schema
            """
        )
        
    CustomDeleteSchema(data: SchemaInput!): Schema!
        @cypher(
            statement: """
				WITH {
					pbotID: "Not yet implemented"
				} AS result
                RETURN result                
            """
        )

    CustomCreateCharacter(data: CharacterInput!): Character!
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (schema)<-[:CHARACTER_OF]-(character:Character {
                        pbotID: apoc.create.uuid(),
                        name: $data.name,
                        definition: $data.definition
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person)
                RETURN character
            """
        )

    CustomUpdateCharacter(data: CharacterInput!): Character!
        @cypher(
            statement: """
                MATCH 
					(character:Character {pbotID: $data.pbotID}),
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
					(:Schema)<-[oldSchemaRelationship:CHARACTER_OF]-(character)
                WITH character, schema, person, oldSchemaRelationship
                SET 
                    character.name = $data.name,
                    character.definition = $data.definition
				CREATE
					(character)-[:ENTERED_BY {timestamp: datetime()}]->(person)
                DELETE oldSchemaRelationship
                CREATE
                    (character)-[:CHARACTER_OF]->(schema)
                RETURN character
            """
        )
        
    CustomDeleteCharacter(data: CharacterInput!): Character!
        @cypher(
            statement: """
				WITH {
					pbotID: "Not yet implemented"
				} AS result
                RETURN result                
            """
        )

    CustomCreateState(data: StateInput!): State!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CALL apoc.case([
                    $data.parentStateID is null, "MATCH (parent:Character {pbotID: characterID}) RETURN parent",
                    $data.parentStateID is not null, "MATCH (parent:State {pbotID: parentStateID}) RETURN parent"],
                    'RETURN "" as parent',
                    {characterID: $data.characterID, parentStateID: $data.parentStateID}
                ) YIELD value 
                WITH value.parent as parent, person
                    CREATE 
                        (parent)<-[:STATE_OF]-(state:State {
                            pbotID: apoc.create.uuid(),
                            name: $data.name,
                            definition:$data.definition
                        })-[:ENTERED_BY {timestamp: datetime()}]->(person)
                    RETURN state           
            """
        )

    CustomUpdateState(data: StateInput!): State!
        @cypher(
            statement: """
                MATCH 
					(state:State {pbotID: $data.pbotID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
					()<-[oldParentRelationship:STATE_OF]-(state)
                CALL apoc.case([
                    $data.parentStateID is null, "MATCH (parent:Character {pbotID: characterID}) RETURN parent",
                    $data.parentStateID is not null, "MATCH (parent:State {pbotID: parentStateID}) RETURN parent"],
                    'RETURN "" as parent',
                    {characterID: $data.characterID, parentStateID: $data.parentStateID}
                ) YIELD value 
                WITH value.parent as parent, person, state, oldParentRelationship
                SET 
                    state.name = $data.name,
                    state.definition = $data.definition
                CREATE
					(state)-[:ENTERED_BY {timestamp: datetime()}]->(person)
                DELETE oldParentRelationship
                CREATE
                    (state)-[:STATE_OF]->(parent)
                RETURN state           
            """
        )
        
    CustomDeleteState(data: StateInput!): State!
        @cypher(
            statement: """
				WITH {
					pbotID: "Not yet implemented"
				} AS result
                RETURN result                
            """
        )

    CustomCreateDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
                    (specimen:Specimen {pbotID: $data.specimenID})
                CREATE 
                    (schema)<-[:APPLICATION_OF]-(description: Description {
                        pbotID: apoc.create.uuid(),
                        type: $data.type,
                        name: $data.name,
                        family: $data.family,
                        genus: $data.genus,
                        species: $data.species
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person)
                WITH description, specimen
                CALL apoc.do.when(
                    specimen is not null, 
                    "CREATE (specimen)-[:DESCRIBED_BY]->(description) RETURN description", 
                    'RETURN description',
                    {specimen: specimen, description: description}
                ) YIELD value
                RETURN value.description AS description                
            """
        )

    CustomUpdateDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
					(description:Description {pbotID: $data.pbotID}),
                    (schema:Schema {pbotID: $data.schemaID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
                    (specimen:Specimen {pbotID: $data.specimenID})
                OPTIONAL MATCH
					(:Schema)<-[oldSchemaRelationship:APPLICATION_OF]-(description)
                OPTIONAL MATCH
					(:Specimen)-[oldSpecimenRelationship:DESCRIBED_BY]->(description)
				SET
					description.type = $data.type,
					description.name = $data.name,
					description.family = $data.family,
					description.genus = $data.genus,
					description.species = $data.species
				DELETE oldSchemaRelationship 
                CREATE 
                    (schema)<-[:APPLICATION_OF]-(description)
				CREATE
					(description)-[:ENTERED_BY {timestamp: datetime()}]->(person)
                WITH description, specimen, oldSpecimenRelationship
                CALL apoc.do.when(
                    specimen is not null, 
                    'DELETE oldSpecimenRelationship CREATE (specimen)-[:DESCRIBED_BY]->(description) RETURN description', 
                    'RETURN description',
                    {specimen: specimen, description: description, oldSpecimenRelationship: oldSpecimenRelationship}
                ) YIELD value
                RETURN value.description AS description                
            """
        )
        
    """NOTE: For now, only allowing delete of nodes entered by same user. Will likely need further logic here.
    ALSO NOTE: This only works if there is one ENTERED_BY relationship. It's weird. Executing manually without the apoc.do.when,
    it works just fine. But with the apoc call, it chokes with a "node still has relationships" error. I'm guessing that only 
    one ENTERED_BY is passed into the apoc routine at a time. If so, would need to wrap the apoc call in an UNWIND. Not quite
    sure how to do that."""
    CustomDeleteDescription(data: DescriptionInput!): Description!
        @cypher(
            statement: """
                MATCH 
                    (description:Description {pbotID: $data.pbotID})-[enteredBy:ENTERED_BY]->(person:Person {pbotID:$data.enteredByPersonID})
                OPTIONAL MATCH
                    (description)-[applicationOf:APPLICATION_OF]->(:Schema)
                OPTIONAL MATCH
                    (description)-[definedBy:DEFINED_BY]->(:CharacterInstance)
                OPTIONAL MATCH
                    (description)<-[describedBy:DESCRIBED_BY]-(:Specimen)
                WITH definedBy, enteredBy, applicationOf, describedBy, description
                CALL apoc.do.when(
                    definedBy is not null, 
                    'RETURN "Cannot delete node " + description.pbotID + " because it has CharacterInstances" AS result', 
                    'UNWIND enteredBy AS eb DELETE eb WITH collect(eb) AS dummy, applicationOf, describedBy, description DELETE applicationOf, describedBy WITH description, description.pbotID AS dID DELETE description RETURN dID + " deleted" AS result',
                    {definedBy: definedBy, enteredBy:enteredBy, applicationOf: applicationOf, describedBy: describedBy,  description: description}
                ) YIELD value
				WITH {
					pbotID: value.result
				} AS result
                RETURN result                
            """
        )

    """NOTE: No when is needed for the HAS_STATE value property below since setting properties to null 
    means they don't exist."""
    CustomCreateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (description:Description {pbotID: $data.descriptionID}),
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (description)-[:DEFINED_BY]->(characterInstance:CharacterInstance {
                        pbotID: apoc.create.uuid()
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person),
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity}]-(characterInstance) 
                RETURN characterInstance
            """
        )

    CustomUpdateCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
                MATCH 
                    (characterInstance:CharacterInstance {pbotID: $data.pbotID}),
                    (character:Character {pbotID: $data.characterID})<-[:STATE_OF*1..100]-(state:State {pbotID: $data.stateID}),
                    (person:Person {pbotID: $data.enteredByPersonID})
                OPTIONAL MATCH
					(:Character)<-[oldCharacterRelationship:INSTANCE_OF]-(characterInstance)
                OPTIONAL MATCH
					(:State)<-[oldStateRelationship:HAS_STATE]-(characterInstance)
                DELETE oldCharacterRelationship
                DELETE oldStateRelationship
                CREATE 
                    (characterInstance)-[:ENTERED_BY {timestamp: datetime()}]->(person),
                    (character)<-[:INSTANCE_OF]-(characterInstance),
                    (state)<-[:HAS_STATE {value: $data.quantity}]-(characterInstance) 
                RETURN characterInstance
            """
        )

    CustomDeleteCharacterInstance(data: CharacterInstanceInput!): CharacterInstance!
        @cypher(
            statement: """
				WITH {
					pbotID: "Not yet implemented"
				} AS result
                RETURN result                
            """
        )

    CustomCreateSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID}),
                    (organ:Organ {pbotID: $data.organID})
                OPTIONAL MATCH
                    (description:Description {pbotID: $data.descriptionID})
                OPTIONAL MATCH
                    (otu:Description {pbotID: $data.otuID})
                CREATE
                    (organ)<-[:IS_TYPE]-(specimen:Specimen {
                        pbotID: apoc.create.uuid(),
                        name: $data.name,
                        locality: $data.locality,
                        preservationMode: $data.preservationMode,
                        idigbiouuid: $data.idigbiouuid,
                        pbdbcid: $data.pbdbcid,
                        pbdboccid: $data.pbdboccid
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person)
                WITH specimen, description, otu
                    CALL apoc.do.when(
                        description IS NOT NULL,
                        "CREATE (description)<-[:DESCRIBED_BY]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {description: description, specimen: specimen}) YIELD value
                    WITH value.specimen AS specimen, otu
                    CALL apoc.do.when(
                        otu IS NOT NULL,
                        "CREATE (otu)<-[:EXAMPLE_OF]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {otu: otu, specimen: specimen}) YIELD value
                RETURN value.specimen as specimen           
            """
        )

    CustomUpdateSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
                MATCH 
					(specimen:Specimen {pbotID: $data.pbotID}),
                    (person:Person {pbotID: $data.enteredByPersonID}),
                    (organ:Organ {pbotID: $data.organID}),
					(specimen)-[oldOrganRelationship:IS_TYPE]->(:Organ)
                OPTIONAL MATCH
                    (description:Description {descriptionID: $data.descriptionID})
                OPTIONAL MATCH
                    (otu:Description {pbotID: $data.otuID})
                OPTIONAL MATCH
					(specimen)-[oldDescribedByRelationship:DESCRIBED_BY]->(:Description)
                OPTIONAL MATCH
					(specimen)-[oldExampleOfRelationship:EXAMPLE_OF]->(:Description)
				SET
                    specimen.name = $data.name,
                    specimen.locality = $data.locality,
                    specimen.preservationMode = $data.preservationMode,
                    specimen.idigbiouuid = $data.idigbiouuid,
                    specimen.pbdbcid = $data.pbdbcid,
                    specimen.pbdboccid = $data.pbdboccid
				DELETE oldOrganRelationship 
                CREATE 
                    (organ)<-[:IS_TYPE]-(specimen)
				CREATE
					(specimen)-[:ENTERED_BY {timestamp: datetime()}]->(person)
                WITH specimen, description, otu, oldDescribedByRelationship, oldExampleOfRelationship
                    CALL apoc.do.when(
                        description IS NOT NULL,
                        "DELETE oldDescribedByRelationship CREATE (description)<-[:DESCRIBED_BY]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {description: description, specimen: specimen, oldDescribedByRelationship: oldDescribedByRelationship}) YIELD value
                    WITH value.specimen AS specimen, otu, oldExampleOfRelationship
                    CALL apoc.do.when(
                        otu IS NOT NULL,
                        "DELETE oldExampleOfRelationship CREATE (otu)<-[:EXAMPLE_OF]-(specimen) RETURN specimen",
                        "RETURN specimen",
                        {otu: otu, specimen: specimen, oldExampleOfRelationship: oldExampleOfRelationship}) YIELD value
                RETURN value.specimen as specimen           
            """
        )
        
    CustomDeleteSpecimen(data: SpecimenInput!): Specimen!
        @cypher(
            statement: """
				WITH {
					pbotID: "Not yet implemented"
				} AS result
                RETURN result                
            """
        )

    CustomCreateOrgan(data: OrganInput!): Organ!
        @cypher(
            statement: """
                MATCH 
                    (person:Person {pbotID: $data.enteredByPersonID})
                CREATE 
                    (organ:Organ {
                        pbotID: apoc.create.uuid(),
                        type: $data.type
                    })-[:ENTERED_BY {timestamp: datetime()}]->(person)
                RETURN organ
            """
        )
        
    CustomDeleteOrgan(data: OrganInput!): Organ!
        @cypher(
            statement: """
				WITH {
					pbotID: "Not yet implemented"
				} AS result
                RETURN result                
            """
        )

}
